# [日本語訳]浮動小数点数の高速・高精度な表示方法 -Printing Floating-Point Numbers Quickly and Accurately-
> *Original Article*: https://legacy.cs.indiana.edu/~dyb/pubs/FP-Printing-PLDI96.pdf
> 
> This article is translated by [@mox692](https://twitter.com/mox692). Please contact me if any problem.

* 数式が多い章は、多分原文を読んだ方が正確だし理解が速そうです.

## Abstruct
要旨本論文では，浮動小数点数を表示と固定形式の両方で表示するための高速かつ正確なアルゴリズムを紹介する．表示モードでは、このアルゴリズムは、最短で正しく丸められた出力文字列を生成し、読み込んだときに、丸めるときにどのようにタイを分割しても、同じ数に変換される。固定形式モードでは、アルゴリズムは、重要でない末尾の桁を示す特別な#マークを使用して、正しく丸められた出力文字列を生成します。どちらのモードでも、アルゴリズムは、浮動小数点数を効率的にスケーリングする高速推定器を使用します。

## 概要
本論文では、入力ベース（通常は2の累乗）から出力ベース（通常は10）への浮動小数点数の変換という出力問題を解決する、効率的な浮動小数点数表示アルゴリズムを紹介します。このアルゴリズムは、表示と固定形式の2種類の出力をサポートしています。表示の出力では、正確な浮動小数点入力ルーチンで読み込んだときに同じ内部浮動小数点数に変換される、最短で正しく丸められた出力文字列を生成することが目的です[1]。

例えば、3/10は0.2999999ではなく0.3として表示されます。入力がニアレストモードであると仮定すると、このアルゴリズムは、例えばIEEE不偏丸めなどのあらゆるタイブレイク戦略に対応します。丸めなど、あらゆる同点解消法に対応します。

固定フォーマット出力では、重要なポイントを超える「ゴミ桁」なしに、与えられた桁数で正しく丸められた出力を生成することが目標です。例えば、1/3の浮動小数点表現は、最初の7桁だけが重要であるにもかかわらず、0.3333333148と表示されるかもしれません。このアルゴリズムでは、特別な#マークを使って重要でない末尾の桁を示し、1/3が0.3333333##と表示されるようにします。これらのマークは、数桁の精度しかないような非正規化された数値を表示するときや、大きな桁数で表示するときに便利です。

彼らのアルゴリズムは、表示と固定形式の両方の出力をサポートしますが、入力のタイブレーキング戦略を適切に処理せず、有意なゼロと重要でない末尾のゼロを区別しません。さらに、実用上許容できないほど遅い。変換アルゴリズムで重要なステップは、浮動小数点数を出力基底の適切なべき乗でスケーリングすることです。Steele と White の反復アルゴリズムでは、O(|log x|) の高精度整数演算を必要とするため、非常に大きな振幅と非常に小さな振幅を持つ浮動小数点数に対して性能が低くなってしまいます。我々は、常に正しいべき乗の1以内の推定値を生成する効率的な推定器を開発し、我々のアルゴリズムは、わずか数回の高精度整数演算ですべての浮動小数点数をスケーリングします。セクション 2 では、厳密な有理数演算の観点から、基本的な浮動小数点印刷アルゴリズムを開発する。セクション3では、高精度整数演算と我々の効率的なスケーリングファクトリステメータを用いたアルゴリズムの実装を説明する。セクション4では、このアルゴリズムを拡張し、固定形式の出力を扱えるようにし、#マークを導入した。セクション5では、我々の結果を要約し、関連する仕事について議論する。

## 基本的なアルゴリズムの概要
基本アルゴリズムの説明では、まず、IEEE の倍精度浮動小数点仕様を例に、浮動小数点数の表現方法について説明する[3]。次に、浮動小数点数の表現の主要な特徴である浮動小数点数間のギャップに基づく出力アルゴリズムを開発する。最後に、このアルゴリズムが、入力時に元の浮動小数点数を復元できる最短の、正しく丸められた出力文字列を生成することを証明する。

## 2.1 浮動小数点数の表現
浮動小数点数の設計における重要な目標は、実数をある桁数の精度で近似することができる表現を提供することです。浮動小数点数は、最初の数桁の有効数字に対応する仮数と、小数点の位置に対応する指数によって数学的にモデル化されます。例えば、vがb（通常は2）進数の浮動小数点数であるとします。仮数 f と指数 e は v = f × be かつ |f| < bp となるような base-b 整数で、p は仮数の固定サイズ (base-bdigits) です。さらに、bp-1 ≤ |f|、すなわち、仮数がゼロでない桁で始まる場合、v は正規化と呼ばれます。正規化されていない、ゼロでない浮動小数点数は、仮数を左にシフトし、それに応じて指数を減らすことによって正規化することができます。しかし、指数は固定サイズを持っているので、いくつかの数は正規化することはできません。そのような数は、非正規化浮動小数点数と呼ばれています。入力ベースが2である場合、正規化、非ゼロ数の仮数は常に1で始まる。その結果、この最初のビットはしばしば表現から省かれ、隠れビットと呼ばれます。IEEE仕様[3]は、-0.0、正の無限大（+inf）、負の無限大（-inf）、および「数字ではない」（NaN）についての表現も提供しています。 IEEE倍精度浮動小数点数vは、1ビットの符号、11ビットの符号なしバイアス指数（be）、および隠しビット付きの52ビット符号なし仮数（m）の3つのフィールドからなる64ビットデータとして表現されます。1≦be≦2046のとき、vは符号(252+m)×2be-1075の正規浮動小数点数であり、be=0のとき、vは符号m×2-1074で、+0と-0を含む正規化浮動小数点数である。be = 2047 and m = 0, vは符号によって+infまたは-infとなる。このような表現では、浮動小数点数の間に不均等な隙間が生じます。浮動小数点数はゼロ付近で最も密度が高く、実数線に沿って外側に向かうにつれて密度が低くなります。浮動小数点数vが与えられたとき、v+で示される後継の浮動小数点数とv-で示される前任者を定義しておくと便利です。v-+v2とv+v+2間の実数はすべてvに丸まります。ここではf > 0の場合を考えるが、f < 0の場合も全く同様である。すべてのvについて、v+は(f + 1) ×beである。f + 1がもはや固定サイズの仮数に収まらない場合、すなわちf + 1 = bpの場合、v+はbp-1 × be+1である。eを最大指数とすると、v+は+infとなる。ほとんどのvについて、v-は(f - 1) ×beとなる。残りのvでは、その差はより小さくなる。f=bp-1でeが最小指数より大きい場合、v-は(bp-1)×be-1である。

## 2.2 アルゴリズム
ここでは、入力時に元の浮動小数点数を復元できる、最短で正しく丸められた出力文字列を生成するために、浮動小数点数間のギャップを利用するアルゴリズムを開発します。仮数と指数で正の浮動小数点数 v が与えられると、アルゴリズムは v- と v+ を使用して、入力時に v に丸められる正確な値の範囲を決定します。入力丸めアルゴリズムは、同値を解消するために異なる戦略を用いるので（例えば、切り上げまたは偶数に丸める）、我々は当初、丸め範囲の両端が入力時にvに丸めることを保証できないと仮定する。第3節では、特定の入力丸めアルゴリズムに関する知識に基づいて、この制約を緩和する方法を示す。このアルゴリズムは、正確な有理数演算を用いて計算を行うため、精度の損失はない。
桁を生成するために、このアルゴリズムは、0.d1d2 ...（d1、d2、...はBase-B桁）の形になるように、数をスケーリングする。最初の桁は、スケーリングされた数値に出力ベースであるBを乗じ、整数部を取ることで計算されます。余りは、同じ方法を用いて残りの桁を計算するために使用されます。各桁が生成された後、アルゴリズムは、結果の数または最後の桁を増加させた結果の数のいずれかがvの丸め範囲内であるかどうかをテストします。同数の場合は、入力時にどちらの可能性もvに丸められるので、どのような方法で決定してもよい。各桁で出力数をテストすることにより、このアルゴリズムは、入力時にvに正しく丸められる最短の出力文字列を生成する。さらに、キャリーを伝搬させることなく、左から右へ数字を生成する。以下は、このアルゴリズムのより正式な説明である。x以下の最大の整数をbxc、x以上の最小の整数をdxe、x-bxcを{x}と表現する。乗算は常に×印で表す。これは、位取り表記で桁を示すために並置を用いるからである。
