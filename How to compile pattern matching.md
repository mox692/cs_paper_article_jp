# [日本語訳]どのようにパターンマッチをコンパイルするか -How to compile pattern matching-
> *Original Article*: https://julesjacobs.com/notes/patternmatching/patternmatching.pdf
> 
> This article is translated by [@mox692](https://twitter.com/mox692). Please contact me if any problem.

## 1 Introduction
私たちのゴールは下記のようなMLスタイルなパターンマッチングをコンパイルすることです.

<img width="835" alt="1" src="https://user-images.githubusercontent.com/55653825/174468772-578b0dbd-f346-45f4-b9c9-b6219554b33c.png">  

わかりやすくするために、値を持つ束縛されたローカル変数には緑色の変数`a`を、パターンマッチによって値が与えられる変数には赤色の変数`x`を使うことにします。  
これをコンパイルする素朴な方法は、パターンを上から下へとテストしていき、それぞれのパターンに対して`a`をそれぞれのパターンに対してマッチングさせることです。しかし、これは非効率的です。もしaの最初の外側コンストラクタがAddであり、Addの内側のパターンマッチで失敗すると、Addのパターンマッチを取りやめ、2番目のパターンであるaがMulであるかどうかをテストします。これはすでにaがAddのパターンであることが判明しているのことを考えると、非効率です。次に3番目のパターンでaがAddであるかどうかをもう一度テストします。この通り冗長である。  
私たちはパターン・マッチを、不必要なテストをしないコードにコンパイルしたいのです。

これは、最初のパターンからマッチを始めなければならないことを意味する。 最初のパターンが成功すれば、他のパターンにマッチさせる作業は不要になる。つまり、我々の戦略は最初のパターンに完全に一致させようとする素朴な戦略を基本的にとるが、マッチング処理の途中で失敗すると、その時点までで学習したことを思い出して、残りのパターンマッチは、学習したことを考慮した特別なバージョンにコンパイルするというものである。

## 2 コンパイルの例
マッチ式は、暗黙のうちに外側の変数`a`に対してテストするパターンのリストとしてではなく、それぞれが何に対してテストするかを明示的に指定する項のリストとして表現すると便利です。

<img width="760" alt="2" src="https://user-images.githubusercontent.com/55653825/174468775-bbfb319e-a85c-4307-a03b-1232da7dc600.png">  


また一般に、それぞれの項は複数のテストをもちうり、それは下記のように表現できる

<img width="706" alt="3" src="https://user-images.githubusercontent.com/55653825/174468778-9170080e-0e98-445b-8829-0ab9ae612b13.png">  

ここで `a1, ... ak`は束縛された変数を表し、`pattern1, ... patternk`はパターンを表す. このような表現を追加するとパターンマッチのコンパイルに便利に働く場面がある.(補足:)
我々の目標は、このような項(補足:ここの「項」はテストと同義)のリストを入力とし、最も原始的な単一のコンストラクタに対してテストするパターンマッチのツリー (match#) を出力するアルゴリズムである。

<img width="797" alt="4" src="https://user-images.githubusercontent.com/55653825/174468779-f937c9f6-01a2-4eaf-84f4-f348e1144e92.png">  


例を使ってこれをどのように行うかを見てみましょう。`a`に対してAddコンストラクタに対してmatchさせるような次の例を考えます

<img width="752" alt="5" src="https://user-images.githubusercontent.com/55653825/174468781-77a579ff-491b-494a-a412-2cfe00561809.png">

そして、Aについて次のような部分問題を解くことになる。(補足:図1からこの部分問題をどのように構築するかは、後の章で述べられる.)
<img width="783" alt="6" src="https://user-images.githubusercontent.com/55653825/174468782-e9c549f7-6876-4ad5-9a25-7892cb73d3ac.png">

ここで、(先ほど述べたように)生成された`a1`と`a2`に対応する複数のテストが項ごとに存在することに注目してください。(補足: ここで言われているように「項」という単語はマッチ1行(マッチアームともしばしば言われる)全体を指す意味で使われており、「テスト」は`a is xxx`のような、項の中の左側の部分を指していることが多い.) これらの問題を単純化するために、例えば 「a2 is y」のような束縛されていない変数に関するテストを右辺に押し込むことで簡略化できる。(補足:この操作に関するメリットは[こちら](https://gitlab.com/yorickpeterse/pattern-matching-in-rust/-/tree/main/jacobs2021#:~:text=It%20reduces%20the,about%20variable%20patterns.)で良く説明されています) そうすると、Aの部分問題は次のようになる。  


<img width="718" alt="7" src="https://user-images.githubusercontent.com/55653825/174468784-003950de-3f43-46fd-9768-423d95abad2c.png">  


そして我々は次に `a1 = zero` のマッチを、次のようなパターンマッチを生成することによって続けることができる.

<img width="806" alt="8" src="https://user-images.githubusercontent.com/55653825/174468785-49ab4eaf-6af4-4a24-9d03-f659bd68f748.png">  

そして CとDに関して再帰的に続けていきます。
図xにおける部分問題Aはこのように構築されていきます. 一方で部分問題Bは元の問題から `a is Add(...)` の形をしている全ての項を取り除いた項の集合として表すことができます.

<img width="760" alt="9" src="https://user-images.githubusercontent.com/55653825/174468786-6171e5c7-c879-457b-997a-6097c0355483.png">  

## 3 アルゴリズム
一般化して何が行われているか見てみよう。パターンマッチングツリーを生成するための項のリストが与えられたとき ツリーを生成するために下記のアルゴリズムを使用します。

1. `a is y` のような、(具体的な値ではない)変数に関する条件は、`let y = a` 構文を用いてマッチの右側に追いやります. これは、マッチ式の左側をマッチに使用できる純粋なコンストラクタ形式のみにするために行われます.
2. 1つの項の中で、 `a is C(...)` というテストをヒューリスティック(後述)を使って1つ選択します. 
3. 次のようなパターンマッチを生成します
<img width="757" alt="10" src="https://user-images.githubusercontent.com/55653825/174468787-d07efea8-8d31-4e9e-966f-592ef11de780.png">  

4. マッチ式の全ての項(補足:ここでの項は、テストの中に存在する項を指す)を探索し下記の操作を行いながら、マッチ式を[A], [B]の2つの部分問題にします
* 項はaに関するテスト`a is C(P1, . . . , Pn)`を所有している. この場合は展開した項 `a1 is P1 ... an is Pn` をAに追加する
* Cと一致しない型Dで、`a is D(P1...Pn)` となっている時、これらの項をBに追加する
* 項がaに関するテストを保持していないときは、A,Bの双方に追加する
5. [A]と[B]のコード生成を再帰的に行う.

これらの再帰は、次のような初期状態をもつ
* 項のリストがなにもない時.これはエラーとして扱う
* はじめの項が空、つまりマッチに成功したときは、右側のeiを返す


## 4 ヒューリスティック
最初の項からどのテストを選んで分岐させるか、どのように決定するのでしょうか？どんなテストでもいいのですが、私たちは コンパクトなパターンマッチングツリーを生成したい。他の項がケース(c)に入るたびに、その項をAとBの両方に追加しなければならない。これを避けるためにコードの爆発が最も少ないテストを選択したい。
