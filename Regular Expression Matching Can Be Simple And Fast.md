# [日本語訳]正規表現マッチングをより簡単かつ高速に行う -Regular Expression Matching Can Be Simple And Fast-
> *Original Article*: https://swtch.com/~rsc/regexp/regexp1.html  
> 
> This article is translated by [@mox692](https://twitter.com/mox692). Please contact me if any problem.

* 記事中のソースコードは[こちら](https://swtch.com/~rsc/regexp/)から参照できます.
* 本文の *History and References* 以降は省略しています.

## Introduction
これは、正規表現マッチングに対する二つのアプローチの物語である。そのうちの 1 つは、Perl を含む多くの言語の標準的なインタプリタで広く使用されています。もうひとつはごく一部の場所、特に awk や grep のほとんどの実装で使用されています。この 2 つのアプローチの性能は大きく異なっています。

![0](https://user-images.githubusercontent.com/55653825/168407121-35c7ecb0-14f7-481d-a565-25cbd234d8b7.png)
![1](https://user-images.githubusercontent.com/55653825/167287406-a385804f-03e3-4b8a-a2e0-d7652c9b68f9.png)  

<div style="text-align: center;">
Time to match a?<sup>n</sup>an against a<sup>n</sup></div>    
  

文字列の繰り返しを表すために上付き添え字を使い、a?<sup>3</sup>a<sup>3</sup>はa?a?a?aaaの略記とする。2つのグラフは、文字列a<sup>n</sup>に対して正規表現a?<sup>n</sup>a<sup>n</sup>をマッチさせるために、各アプローチが必要とする時間をプロットしたものです。 

Perlでは29文字の文字列をマッチさせるのに60秒以上かかっていることに注意してください。もう一つの方法は、後で説明する理由によりThompson NFAと名付けられ、文字列をマッチさせるのに20マイクロ秒を必要とします。これはタイプミスではありません。Perlのグラフは秒単位で、Thompson NFAのグラフはマイクロ秒単位で表示します。わずか29文字の文字列に対して、Thompson NFAの実装はPerlの100万倍も高速です。このグラフの傾向はさらに続き、100文字の文字列を処理する場合、Thompson NFAは200マイクロ秒以下で、Perlは10<sup>15</sup>年以上かかると言われています。(Perlは、同じアルゴリズムを使っている多くの人気プログラムの中で最も目立つ例に過ぎず、上のグラフはPython、PHP、Ruby、あるいは他の多くの言語でも可能だったのです）。この記事の後半にあるより詳細なグラフで、他の実装のデータを紹介しています)。

このグラフを信じるのは難しいかもしれません。おそらくあなたはPerlを使っていて、正規表現のマッチングが特に遅いとは感じなかったでしょう。実際、ほとんどの場合、Perl の正規表現マッチングは十分に高速です。しかし、グラフが示すように、いわゆる「病的な」正規表現を書くと、Perlのマッチングが非常に遅くなることがある。一方、Thompson NFA実装では、病的な正規表現は存在しない。この2つのグラフを並べてみると、"なぜPerlはThompson NFAアプローチを使わないのか "という疑問が湧いてきます。それは可能であり、そうすべきであり、この記事の残りの部分はそれについてです。

歴史的に見ると、正規表現はコンピュータサイエンスにおいて、優れた理論がいかに優れたプログラムを生み出すかを示す輝かしい例の1つです。正規表現はもともと単純な計算モデルとして理論家によって開発されましたが、Ken ThompsonがCTSSのためのテキストエディターQEDの実装でプログラマーに紹介しました。その後、Dennis RitchieがGE-TSSのためにQEDの実装を行い、プログラマに紹介しました。トンプソンとリッチーはその後Unixを開発し、正規表現を持ち込んだのです。1970年代後半には、正規表現はed、sed、grep、egrep、awk、lexといったツールで、Unixの風景に欠かせないものとなっていたのです。

今日、正規表現はまた、優れた理論を無視することがいかに悪いプログラムにつながるかを示す輝かしい例となった。今日の一般的なツールで使われている正規表現の実装は、30年前のUnixのツールの多くで使われていたものよりもかなり遅いのです。

この記事では、正規表現、有限オートマトン、そして1960年代半ばに Ken Thompson によって発明された正規表現検索アルゴリズムといった、優れた理論についてレビューします。また、理論を実践し、Thompsonのアルゴリズムの簡単な実装を説明します。この実装はC言語で400行以下であり、上記のPerlと直接対決したものである。この実装は、Perl、Python、PCREなどで使用されている、より複雑な実世界の実装を凌駕しています。この記事は、理論がまだ実世界の実装でどのように実践に移されるかという議論で締めくくられています。

## 正規表現
正規表現は、文字列の集合を記述するための表記法です。ある文字列が正規表現で記述された集合に含まれる場合、その正規表現はその文字列にマッチすると言うことがよくあります。

最も単純な正規表現は1つのリテラル文字です。特別なメタキャラクタ *+?| を除いて、文字はそれ自身にマッチします。メタ文字にマッチするには、それをバックスラッシュでエスケープします。\\+ は、リテラルなプラス文字にマッチします。

e<sub>1</sub> が s にマッチし e<sub>2</sub> が t にマッチする場合、e<sub>1</sub>|e<sub>2</sub> は s または t にマッチし、e<sub>1</sub>e<sub>2</sub> は st にマッチします。

メタキャラクタ *, +, ? は、繰り返し演算子です。 e<sub>1</sub>\* は、それぞれが e<sub>1</sub> にマッチするゼロ個以上の (おそらく異なる) 文字列のシーケンスにマッチし、 e<sub>1</sub>+ は一つ以上にマッチし、e<sub>1</sub>?は0回もしくは1回にマッチします。

演算子の優先順位は、最も拘束力の弱いものから順に、まず交替演算子、次に連結演算子、 そして最後に反復演算子となります。明示的な括弧は、算術式と同じように異なる意味を強制するために使用することができます。例：ab|cd は (ab)|(cd) と等価であり、ab* は a(b*) と等価である。

これまで説明した構文は、伝統的な Unix の egrep 正規表現構文のサブセットです。このサブセットはすべての正規言語を記述するのに十分です。大雑把に言えば、正規言語とは一定のメモリ量だけを使ってテキストを一回でマッチさせることができる文字列の集合のことです。新しい正規表現機能(特にPerlとそれをコピーしたもの)には、多くの新しい演算子とエスケープシーケンスが追加されています。これらの追加により、正規表現はより簡潔で、時にはより不可解になりますが、通常はより強力ではありません。これらの派手な新しい正規表現は、ほとんどの場合、従来の構文を使った長い同等品を持っています。

一般的な正規表現の拡張で、さらなる力を発揮するものの1つに後方参照というものがあります。\1 や \2 のような後方参照は、前の括弧で囲まれた式がマッチした文字列にマッチし、その文字列のみの繰り返しにマッチします。 例えば (cat|dog)\1 は catcat と dogdog にマッチするが、catdog と dogcat にはマッチしない。理論的な用語に関する限り、後方参照を含む正規表現は正規表現ではありません。後方参照が加える力は大きな代償を払います。最悪の場合、最もよく知られた実装はPerlが使っているような指数関数的な探索アルゴリズムを必要とします。もちろん、Perl (および他の言語) は後方参照を削除することはできませんが、後方参照を持たない正規表現が提示されたときに、上で検討したようなずっと高速なアルゴリズムを採用することができます。この記事はそのような高速なアルゴリズムについて書かれています。

## 決定性有限オートマトン
文字列の集合を記述するもう一つの方法は、有限オートマトンを用いることである。有限オートマトンはステートマシンとも呼ばれ、ここでは「オートマトン」と「マシン」を同じ意味で使うことにする。

簡単な例として、正規表現 a(bb)+a にマッチする文字列の集合を認識するマシンを紹介する。

![2](https://user-images.githubusercontent.com/55653825/167287409-29a9c5a8-0ee4-42e9-a6d9-dbff7152a18f.png)

有限オートマトンは常にいずれかの状態にあり、図では丸で表されています。(丸の中の数字は、この議論を容易にするためのラベルであり、機械の動作の一部ではない)。文字列を読み込むと、状態が切り替わる。この機械には、開始状態s0と照合状態s4という二つの特別な状態がある。開始状態は一本の矢じりが指し示すように描かれ、一致状態は二重丸で描かれる。

機械は入力文字列を一度に一文字ずつ読み、入力に対応する矢印に従って状態から状態へ移行する。入力文字列がabbbbaであるとする．機械が文字列の最初の文字であるaを読んだとき、機械は開始状態s0にある。そして、aの矢印をたどって状態s1になる。bからs2、bからs3、bからs2、bからs3、そして最後にaからs4と、残りの文字列を読むとこの過程が繰り返される。 

![3](https://user-images.githubusercontent.com/55653825/167287410-096a00f5-01be-491b-a010-646f89de39f4.png)

機械はs4で終了し、マッチング状態なので、文字列とマッチングします。マシンが非マッチングの状態で終了した場合、文字列にはマッチしない。マシンの実行中のどの時点でも、現在の入力文字に対応する矢印がない場合、マシンは早期に実行を停止する。

私たちが考えてきた機械は決定論的有限オートマトン(DFA)と呼ばれる．なぜなら，どの状態でも，考えられる入力文字が導く新しい状態はせいぜい1つだからである．また、複数の可能な次の状態から選択しなければならない機械も作ることができる。例えば、この機械は前の機械と等価であるが、決定論的で はない。

![4](https://user-images.githubusercontent.com/55653825/167287412-391cadf1-63cc-4b74-931b-cfe40e0fa0b6.png)

もし状態 s2 で b を読んだ場合、次の状態には複数の選択肢があるため、機械は決定論的でない：bbを見るためにs1に戻ることもできるし、最後のaを見るためにs3に進むこともできる。機械は先の文字列を見ることができないので、どちらが正しい判断なのかを知る術がない。このような状況では、機械に常に正しい判断をさせることが興味深い問題であることがわかる。このような機械は非決定性有限オートマトン（NFAまたはNDFA）と呼ばれる。NFAは、入力文字列を読み、矢印をたどってマッチング状態に至る何らかの方法がある場合に、入力文字列にマッチングする。

時には、NFAに対応する入力文字がない矢印を持たせると便利である。このような矢印にはラベルをつけないことにする。NFAはいつでも、入力を読まずにラベルのない矢印をたどることを選ぶことができる。このNFAは前の2つと等価であるが、ラベルのない矢印はa(bb)+aとの対応を最も明確にするものである。

![5](https://user-images.githubusercontent.com/55653825/167287413-866959e6-5331-4efd-84f4-764f652115d1.png)

## 正規表現からNFAへの変換
正規表現とNFAは能力的に全く等価であることが分かっている： すべての正規表現は同等のNFAを持ち（それらは同じ文字列にマッチする）、逆もまた然りである。(DFAもまたNFAや正規表現と同等の力を持っていることがわかったが、これについては後述する)。正規表現をNFAに変換する方法は複数ある。ここで説明する方法は、Thompsonが1968年のCACMの論文で最初に説明したものである。

正規表現のNFAは各副表現の部分NFAから構成され、各演算子ごとに異なる構成となる。部分NFAはマッチング状態を持たず、代わりに何も指していない1つ以上のぶら下がり矢印を持っている。構築プロセスは、これらの矢印をマッチング状態に接続することで終了する。

単一文字にマッチするNFAは次のようになります: 

![6](https://user-images.githubusercontent.com/55653825/167287414-61b58250-c55b-48cb-971b-be82d1dbc52e.png)
 
連結e<sub>1</sub>e<sub>2</sub>のNFAは、e<sub>1</sub>機の最終矢印とe<sub>2</sub>機の始点を結ぶ。

![7](https://user-images.githubusercontent.com/55653825/167287415-cd295fd5-4d96-4c17-b1f4-070a6b3d0965.png)

交互配列e<sub>1</sub>|e<sub>2</sub>のNFAは、e<sub>1</sub>機かe<sub>2</sub>機のどちらかを選択する新しい開始状態を追加する。

![8](https://user-images.githubusercontent.com/55653825/167287417-d64c58ee-9681-4ee4-90c9-5a8c27ab61b6.png)

e?のNFAはeマシンと空のパスを交替させる。

![9](https://user-images.githubusercontent.com/55653825/167287418-ee77b873-4c5a-48b9-be7a-7cec6830a68f.png)

e*のNFAは同じ交互性を用いるが、マッチするeマシンをループさせて最初に戻す。

![10](https://user-images.githubusercontent.com/55653825/167287458-ad2eb07d-0927-462c-a788-05d450662335.png)

上の図で新しい状態を数えてみると、この手法では、括弧を除く正規表現の文字やメタキャラクタごとにちょうど1つの状態が生成されることがわかる。したがって、最終的なNFAにおける状態の数は、最大でも元の正規表現の長さに等しくなる。

先に述べたNFAの例と同様に、ラベルのない矢印を取り除くことは常に可能であり、またそもそもラベルのない矢印を含まないNFAを生成することも常に可能である。ラベルのない矢印があるとNFAが読みやすく理解しやすくなるし、C言語の表現もより単純になるので、そのままにしておく。 

## 正規表現における検索アルゴリズム 
  正規表現をNFAに変換し、文字列を入力としてNFAを実行する。NFAには、次の状態を完全に推測する能力が備わっていることを忘れないでほしい。

完璧な推測をシミュレートする一つの方法は、一つの選択肢を推測し、それがうまくいかない場合は、もう一つの選択肢を試すことである。例えば、abab|abbbのNFAをabbbという文字列に対して実行することを考えてみよう。

![12](https://user-images.githubusercontent.com/55653825/167287431-f2ab8b39-014f-43c3-b684-65ee056f5b90.png)
![13](https://user-images.githubusercontent.com/55653825/167287432-1be5657a-fa33-406b-a0db-fb4c838d8532.png)

ステップ0において、NFAはababと一致させるか、abbbと一致させるかを選択しなければならない。図では、NFAはababを試したが、ステップ3の後で失敗した。次にNFAはもう一方の選択肢を試し、ステップ4に至り、最終的にマッチングが成立する。このバックトラック・アプローチは単純な再帰的実装であるが、成功するまでに何度も入力文字列を読み込むことができる。文字列が一致しない場合、機械はあきらめる前に可能な限りの実行経路を試さなければならない。NFAはこの例では2つの異なる経路を試しただけだが、最悪の場合、可能な実行経路は指数関数的に多くなり、実行時間が非常に遅くなる可能性がある。 

より効率的だが、より複雑な完全推測のシミュレーションを行うには、両方の選択肢を同時に推測する方法がある。この方法では、シミュレーションでは、機械が一度に複数の状態になるようにする。各文字を処理するために、その文字に一致するすべての矢印に沿ってすべての状態を進める。

![14](https://user-images.githubusercontent.com/55653825/167287433-cf41c632-5924-46ba-9034-683a158bb763.png)

機械は開始状態および開始状態からラベルのない矢印で到達可能なすべての状態から開始する。ステップ 1 と 2 では、NFA は同時に 2 つの状態にある。ステップ3においてのみ、状態集合は1つの状態に絞られる。この多状態アプローチは、入力を一度だけ読み、同時に両方の経路を試行する。最悪の場合、NFAは各ステップですべての状態になる可能性があるが、この場合、最悪でも文字列の長さに依存しない一定の作業量になるため、任意の大きさの入力文字列を線形時間で処理することができる。これは、バックトラック手法で必要とされる指数関数的な時間に対して劇的な改善である。この効率は、到達可能な状態の集合を追跡することに由来するが、どの経路で到達したかを追跡するものではない。n個のノードを持つNFAでは、どのステップでもn個の到達可能な状態しかありえないが、NFAを通る経路は2n本あるかもしれない。 

## 実装 
Thompsonは1968年の論文で多状態シミュレーションの手法を紹介した。彼の定式化では、NFAの状態は小さな機械コードの列で表現され、可能な状態のリストは単なる関数呼び出し命令の列であった。つまり、トンプソン氏は正規表現を賢いマシンコードにコンパイルしたのである。40年後、コンピュータはより高速になり、機械コードのアプローチはそれほど必要ではなくなった。以下の節では、移植可能なANSI Cで書かれた実装を紹介する。ソースコード全体（400行以下）とベンチマーク用スクリプトはオンラインで入手可能である。(Cやポインタに馴染みがない、あるいは苦手な読者は、説明を読んで実際のコードを読み飛ばしてください)。

## 実装: NFAへのコンパイル
最初のステップは、正規表現を等価なNFAにコンパイルすることである。このCプログラムでは、NFAをState構造体のリンクした集合体として表現する。

```c
struct State
{
	int c;
	State *out;
	State *out1;
	int lastlist;
};
```

各Stateは、cの値に応じて、以下の3つのNFAフラグメントのいずれかを表す。

![15](https://user-images.githubusercontent.com/55653825/167287434-933a8f44-5272-47c9-914b-db010afc573e.png)

(Lastlistは実行時に使用され，次節で説明する)．

Thompsonの論文に従い、コンパイラはドット(.)を明示的な連結演算子として加えた postfix記法の正規表現からNFAを構築する。別の関数re2postは、"a(bb)+a "のようなinfix正規表現を "abb.+.a. "のような等価なpostfix表現に書き換える。(実際の正規表現では、ドット(.)は連結演算子としてではなく、「任意の文字」メタキャラクタとして使う必要があることは間違いないでしょう。また、実際の実装では、このタイミングで明示的なpostfix表現を構築するのではなく、すぐさまパースしてNFAを構築することになるだろう。しかし、postfix表現は便利であり、Thompsonの論文により近いものであるため、こちらを採用する)。

コンパイラはpostfix表現をスキャンする際に、計算されたNFAフラグメントのスタックを維持する。リテラルは新しいNFAフラグメントをスタックにプッシュし、演算子はフラグメントをスタックからポップし、新しいフラグメントをプッシュする。例えば、abb.+.a.のabbをコンパイルした後(ドット . は連結演算子であることに注意)、スタックにはa、b、およびbのNFAフラグメントが含まれる。 その後の.のコンパイルでは、スタックから2つのb NFAフラグメントをポップし、 連結のbb.のNFAフラグメントをプッシュする。各NFAフラグメントはその開始状態と出て行く矢印によって定義される。

```c
struct Frag
{
	State *start;
	Ptrlist *out;
};
```

Startはフラグメントの開始状態を指し、outはまだ何にも接続されていないState*ポインタのリストである。これらは、NFAフラグメントのぶら下がった矢印である。

いくつかのヘルパー関数はポインタリストを操作する。

```c
Ptrlist *list1(State **outp);
Ptrlist *append(Ptrlist *l1, Ptrlist *l2);

void patch(Ptrlist *l, State *s);
```
List1は、単一ポインタoutpを含む新しいポインタリストを作成します。Appendは2つのポインタリストを連結し、その結果を返します。Patchはポインタリストlのぶら下がった矢印を状態sにつなぎます：lの各ポインタoutpに対して*outp = sをセットします。

これらのプリミティブとフラグメントスタックが与えられると、コンパイラはpostfix表現に対する単純なループになります。最後に、1つのフラグメントが残る：マッチング状態でパッチを適用するとNFAが完了します。

```c
State*
post2nfa(char *postfix)
{
	char *p;
	Frag stack[1000], *stackp, e1, e2, e;
	State *s;

	#define push(s) *stackp++ = s
	#define pop()   *--stackp

	stackp = stack;
	for(p=postfix; *p; p++){
		switch(*p){
		/* compilation cases, described below */
		}
	}
	
	e = pop();
	patch(e.out, matchstate);
	return e.start;
}
```

具体的なコンパイルのケースは、先に説明した変換ステップを模倣している。


リテラル文字: ![16](https://user-images.githubusercontent.com/55653825/167287435-e2e0d869-4f90-4217-9717-d8904caa8cd0.png)
```c
default:
	s = state(*p, NULL, NULL);
	push(frag(s, list1(&s->out));
	break;
```

隣接: ![17](https://user-images.githubusercontent.com/55653825/167287436-39854ed3-75b8-40c8-b7ab-531cc04cdf7f.png)
```c
case '.':
	e2 = pop();
	e1 = pop();
	patch(e1.out, e2.start);
	push(frag(e1.start, e2.out));
	break;
```

選択: ![18](https://user-images.githubusercontent.com/55653825/167287437-3c2225c2-2c52-499a-a063-51be02ed42fe.png)
```c
case '|':
	e2 = pop();
	e1 = pop();
	s = state(Split, e1.start, e2.start);
	push(frag(s, append(e1.out, e2.out)));
	break;
```

0回か1回: ![19](https://user-images.githubusercontent.com/55653825/167287439-0572bf5c-bf51-4339-a8ec-b44c634715f4.png)
```c
case '?':
	e = pop();
	s = state(Split, e.start, NULL);
	push(frag(s, append(e.out, list1(&s->out1))));
	break;
```

0回以上: ![20](https://user-images.githubusercontent.com/55653825/167287441-febc1a02-45fa-4acf-b9f0-94faaf16005d.png)
```c
case '*':
	e = pop();
	s = state(Split, e.start, NULL);
	patch(e.out, s);
	push(frag(s, list1(&s->out1)));
	break;
```

1回以上: ![21](https://user-images.githubusercontent.com/55653825/167287442-e9f514f3-c9e9-4f57-b2b7-6d384c0d2a52.png)
```c
case '+':
	e = pop();
	s = state(Split, e.start, NULL);
	patch(e.out, s);
	push(frag(e.start, list1(&s->out1)));
	break;
```

## 実装: NFAをシミュレートする
NFA が構築されたので、それをシミュレートする必要があります。シミュレーションには、単純な配列リストとして格納されている状態集合の追跡が必要です。

```c
struct List
{
	State **s;
	int n;
};
```

シミュレーションでは、次の2つのリストを使用します:clist は NFA が現在置かれている状態の集合であり，nlist は現在の文字を処理した後に NFA が次に置かれる状態の集合である．実行ループは clist を初期化して開始状態だけを含むようにし，一度に 1 ステップずつマシンを実行する．

```c
int
match(State *start, char *s)
{
	List *clist, *nlist, *t;

	/* l1 and l2 are preallocated globals */
	clist = startlist(start, &l1);
	nlist = &l2;
	for(; *s; s++){
		step(clist, *s, nlist);
		t = clist; clist = nlist; nlist = t;	/* swap clist, nlist */
	}
	return ismatch(clist);
}
```

ループの反復毎にアロケートするのを避けるため、matchは事前にアロケートされた2つのリストl1とl2をclistとnlistとして使い、各ステップの後に2つをスワップしている。

最終的な状態リストに一致する状態が含まれていれば、文字列は一致する。
```c
int
ismatch(List *l)
{
	int i;

	for(i=0; i<l->n; i++)
		if(l->s[i] == matchstate)
			return 1;
	return 0;
}
```

Addstateは状態をリストに追加しますが、既にリストにある場合は追加されません。追加するたびにリスト全体をスキャンするのは非効率的なので、代わりに変数listidがリスト生成番号として機能します。addstateがsをリストに追加するとき、s->lastlistにlistidを記録します。この2つがすでに等しい場合、sはすでに構築中のリスト上にある。addstateはラベルのない矢印にも従います。sが新しい状態へのラベルのない2つの矢印を持つ分割状態の場合、addstateはsの代わりにそれらの状態をリストに追加します。

```c
void
addstate(List *l, State *s)
{
	if(s == NULL || s->lastlist == listid)
		return;
	s->lastlist = listid;
	if(s->c == Split){
		/* follow unlabeled arrows */
		addstate(l, s->out);
		addstate(l, s->out1);
		return;
	}
	l->s[l->n++] = s;
}
```

Startlistは、開始状態だけを追加して、初期状態リストを作成します。

```c
List*
startlist(State *s, List *l)
{
	listid++;
	l->n = 0;
	addstate(l, s);
	return l;
}
```

最後に、stepはNFAを1文字分進め、現在のリストclistを使って次のリストnlistを計算する。

```c
void
step(List *clist, int c, List *nlist)
{
	int i;
	State *s;

	listid++;
	nlist->n = 0;
	for(i=0; i<clist->n; i++){
		s = clist->s[i];
		if(s->c == c)
			addstate(nlist, s->out);
	}
}
```

## Performance
今説明したC言語の実装は、性能を意識して書かれたものではありません。それでも、指数が十分に大きければ、線形時間アルゴリズムの遅い実装は指数時間アルゴリズムの速い実装を容易に凌駕することができる。いわゆる病理学的な正規表現について、様々な一般的な正規表現エンジンをテストしてみると、このことがよくわかる。

a?<sup>n</sup>a<sup>n</sup>という正規表現を考えてみよう。これは、a?がどの文字にもマッチしないように選択され、かつ文字列全体がa<sup>n</sup>にマッチするようになったときに、文字列a<sup>n</sup>にマッチします。正規表現のバックトラック実装では、最初に1を試し、次に0を試すことによって、0-or-1 ?このような選択がn回あり、合計2<sup>n</sup>の可能性があります。すべての?をゼロにする最後の可能性だけが、マッチを導きます。このように、バックトラック法はO(2<sup>n</sup>)の時間を必要とするため、n=25を超えるとあまりスケールアップしない。

一方、Thompsonのアルゴリズムでは、長さ約nの状態リストを保持し、同じく長さnの文字列を処理するため、合計O(n<sup>2</sup>)の時間が必要である。(入力が大きくなっても正規表現を一定に保たないので、実行時間は超線形である。長さnのテキストに対して長さmの正規表現を実行する場合、トンプソンNFAはO(mn)の時間を必要とする)。

次のグラフは、?nanが?nに一致するかどうかをチェックするのに必要な時間をプロットしたものです。

![22](https://user-images.githubusercontent.com/55653825/167287443-7800ec91-98a7-4ef7-8470-f95a357e0126.png)


グラフのY軸が対数スケールになっているのは、1つのグラフでさまざまな時間を見ることができるようにするためであることに注意してください。

このグラフから、Perl、PCRE、Python、Rubyが再帰的バックトラックを使用していることがわかります。PCREは最大ステップ数で再帰的バックトラックを中止するため、n=23で正しい答えが得られなくなります。Perl 5.6では、Perlの正規表現エンジンは再帰的バックトラック検索をメモ化すると言われており、ある程度のメモリコストで、後方参照を使用しない限り検索に指数関数的な時間がかからないようにすることができるはずです。性能グラフが示すように、このメモ化は完全ではありません。Perlの実行時間は、式に後方参照がないにもかかわらず、指数関数的に増加します。ここではベンチマークしていないが、Javaもバックトラックの実装を使用している。実際、java.util.regexインターフェイスはバックトラック実装を必要とします。なぜなら、マッチングパスに任意のJavaコードを代入することができるからです。PHP は PCRE ライブラリを使用しています。

青い太線は、上で示したThompsonのアルゴリズムのC実装です。Awk, Tcl, GNU grep, GNU awk は、事前に計算するか、次の節で説明するオンザフライの構築で DFA を構築します。

このテストは、一般的でないコーナーケースに焦点を当てているため、バックトラックの実装に対して不公平であると主張する人もいるかもしれません。しかし次の点を見落としている: つまりすべての入力に対して予測可能で一貫した高速な実行時間を持つ実装と、通常は高速に実行されるが一部の入力に対して何年も（あるいはそれ以上）CPU時間を要する実装のどちらかを選ぶとしたら、その決定は簡単なはずである。また、今回のような劇的な例は実際にはほとんどありませんが、もっと劇的でない例もあります。例えば、スペースで区切られた5つのフィールドを分割するために (.*) (.*) (.*) を使用したり、よくあるケースを最初にリストアップしない交互処理を使用したりすることです。その結果、プログラマはどの構文が高価かを学習し、それを避けるか、いわゆるオプティマイザに頼ることが多くなります。ThompsonのNFAシミュレーションでは、そのような適応は必要ない。高価な正規表現は存在しないのだ。

## NFAをキャッシュしてDFAを構築する

DFAは一度に一つの状態にしかならないので，NFAよりも実行効率が良いことを思い出してください．どんなNFAも等価なDFAに変換することができ、その場合、DFAの各状態はNFAの状態リストに対応する。

例えば、先ほどのabab|abbbのNFAに状態番号をつけたものがこちらです。

![23](https://user-images.githubusercontent.com/55653825/167287444-d6e0efce-cf3d-4942-99f7-97c447e9c6ce.png)

同等のDFAは下記のようになる。

![24](https://user-images.githubusercontent.com/55653825/167287445-da0f416d-8d67-490f-b1c6-aa4187db4782.png)

DFAの各状態は、NFAの状態のリストに対応している。

ある意味で、ThompsonのNFAシミュレーションは等価なDFAを実行していることになる。各リストは何らかのDFA状態に対応し、step関数はリストと次の文字が与えられたときに、次に入るべきDFA状態を計算しているのである。Thompsonのアルゴリズムは、各DFAの状態を必要に応じて再構築することでDFAをシミュレートしています。各ステップ後にこの作業を捨てるのではなく、リストを予備メモリにキャッシュすることで、将来的に計算を繰り返すコストを回避し、本質的に必要なときに同等のDFAを計算することができます。このセクションでは、そのようなアプローチの実装を紹介する。前節のNFA実装から始めて、DFA実装を構築するのに必要な行数は100行未満である。

キャッシュを実装するために、まず、DFAの状態を表す新しいデータ型を導入する。

```c
struct DState
{
	List l;
	DState *next[256];
	DState *left;
	DState *right;
};
```

DState は、リスト l のキャッシュされたコピーです。配列 next には、入力される文字ごとに次の状態へのポインタが含まれています。d->next[c]がnullの場合、次の状態はまだ計算されていない。Nextstateは、与えられた状態と文字に対して次の状態を計算し、記録し、返します。

正規表現マッチはd->next[c]を繰り返したどり、必要に応じてnextstateを呼び出して新しい状態を計算する。

```c
int
match(DState *start, char *s)
{
	int c;
	DState *d, *next;
	
	d = start;
	for(; *s; s++){
		c = *s & 0xFF;
		if((next = d->next[c]) == NULL)
			next = nextstate(d, c);
		d = next;
	}
	return ismatch(&d->l);
}
```

計算されたすべてのDStateは、ListでDStateを検索できるような構造に保存する必要があります。これを行うには、ソートされたListをキーとして二分木に並べます。dstate関数は、与えられたListに対するDStateを返し、必要であれば1つ割り当てる。


```c
DState*
dstate(List *l)
{
	int i;
	DState **dp, *d;
	static DState *alldstates;

	qsort(l->s, l->n, sizeof l->s[0], ptrcmp);

	/* look in tree for existing DState */
	dp = &alldstates;
	while((d = *dp) != NULL){
		i = listcmp(l, &d->l);
		if(i < 0)
			dp = &d->left;
		else if(i > 0)
			dp = &d->right;
		else
			return d;
	}
	
	/* allocate, initialize new DState */
	d = malloc(sizeof *d + l->n*sizeof l->s[0]);
	memset(d, 0, sizeof *d);
	d->l.s = (State**)(d+1);
	memmove(d->l.s, l->s, l->n*sizeof l->s[0]);
	d->l.n = l->n;

	/* insert in tree */
	*dp = d;
	return d;
}
```

NextstateはNFAステップを実行し、対応するDStateを返す。

```c
DState*
nextstate(DState *d, int c)
{
	step(&d->l, c, &l1);
	return d->next[c] = dstate(&l1);
}
```

最後に、DFAの開始状態は、NFAの開始リストに対応するDStateである。

```c
DState*
startdstate(State *start)
{
	return dstate(startlist(start, &l1));
}
```

(NFAシミュレーションと同様、l1は事前に確保されたListです)。

DStatesはDFAの状態に対応するが、DFAは必要に応じて構築されるだけで、探索中にDFAの状態に遭遇しなかった場合は、まだキャッシュに存在しない。代替案として、DFA全体を一度に計算することも可能である。そうすると、条件分岐がなくなるので、マッチングが少し速くなるが、その代償として起動時間とメモリ使用量が増加する。

また、その場でのDFA構築で使用されるメモリ量の上限が気になるところである。DStateはステップ関数のキャッシュに過ぎないので、キャッシュが大きくなりすぎた場合、dstateの実装はこれまでのDFA全体を捨てることを選択することができる。このキャッシュ置き換え方針は、dstateとnextstateで数行の追加コードと、メモリ管理のための50行程度のコードしか必要としない。実装はオンラインで公開されています。(Awkは同様のサイズ制限付きキャッシュ戦略を採用しており、キャッシュされる状態の上限は32個に固定されています。このことが、上のグラフのn=28で性能が不連続になっていることの説明になっています)。

正規表現から派生したNFAは局所性に富む傾向があり、ほとんどのテキストで実行すると、同じ状態を訪れ、同じ遷移矢印を何度もたどる。このため、キャッシュの価値が高い。最初に矢印をたどったときは、NFAシミュレーションと同様に次の状態を計算する必要があるが、それ以降の矢印の走査は1回のメモリアクセスですむ。実際のDFAベースの実装では，さらなる最適化により，さらに高速に動作させることができます．関連記事（未執筆）では、DFAベースの正規表現の実装をより詳しく紹介する予定です。

## 現実における正規表現
実際のプログラムでの正規表現の使い方は、上で説明した正規表現の実装が扱えるものよりもいくらか複雑です。このセクションでは、一般的な複雑さについて簡単に説明します。これらのいずれかを完全に扱うことは、この入門記事の範囲を超えています。

*文字クラス*。文字クラスは[0-9]であろうと、.（ドット）であろうと、単に交番を簡潔に表現したものです。文字クラスはコンパイル時に交互配列に拡張することができますが、新しい種類のNFAノードを追加して明示的に表現した方が効率的です。POSIXは [[:upper:]] のように現在のロケールによって意味が変わる特殊な文字クラスを定義しているが、これらに対応するのは難しいことで、その意味をNFAにエンコードすることではないのだ。

*エスケープシーケンス*。メタキャラクタ( \(, \), \ など)にマッチする方法として、また、 \n のような入力しにくい文字を指定する方法として、実際の正規表現構文ではエスケープシーケンスを扱う必要があります。

*Counted repetition*.多くの正規表現実装では、パターンに一致する文字列がちょうどn個なら{n}、n個以上m個なら{n,m}、n個以上なら{n,}という数合わせの繰り返し演算子が用意されています。NFAやDFAに基づく実装では、繰り返しを展開する必要があります。e{3}はeeに、e{3,5}はeee?e?に、e{3,}はee+に展開されます。

*サブマッチ抽出*サブマッチの抽出正規表現を文字列の分割や解析に使う場合、入力文字列のどの部分がそれぞれの部分式にマッチしたかを調べられると便利です。([0-9]+-[0-9]+-[0-9]+) ([0-9]+:[0-9]+) のような正規表現が文字列（例えば日付と時刻）にマッチした後、多くの正規表現エンジンはそれぞれの括弧付きの表現でマッチしたテキストを利用できるようにします。例えば、Perlで次のように書くことができます。

if(/([0-9]+-[0-9]+-[0-9]+) ([0-9]+:[0-9]+)/){
print "date: $1, time: $2n";
}
サブマッチ境界の抽出は、計算機科学の理論家からはほとんど無視されており、再帰的バックトラックを使うための最も説得力のある議論であると思われる。しかし、Thompsonスタイルのアルゴリズムは、効率的な性能を犠牲にすることなく、サブマッチ境界を追跡するように適合させることができます。第8版のUnix regexp(3)ライブラリは1985年という早い時期にそのようなアルゴリズムを実装していましたが、以下に説明するように、あまり広く使われず、注目さえされていませんでした。

アンカー付きマッチこの記事では、正規表現が入力文字列全体に対してマッチされることを仮定しています。実際には、正規表現にマッチする入力の部分文字列を見つけたいと思うことがよくある。Unix のツールは伝統的に、入力の可能な限り左端から始まる最も長い部分文字列を返します。eのアンカリング検索はサブマッチ抽出の特殊なケースです。これは、最初の.*ができるだけ短い文字列にマッチするように制約されている .*(e).* を検索しているようなものです。

非貪欲な演算子。伝統的な Unix の正規表現では、繰り返し演算子 ?, *, + は正規表現全体がマッチするようにしつつ、できるだけ多くの文字列にマッチするように定義されています。abcd に対して (.+)(.+) をマッチさせると、最初の (.+) は abc、2 番目は d にマッチします。これは、全体のマッチングを維持しつつ、できるだけ文字列の一部をマッチングさせるものです。(.+?)(.+?) と abcd をマッチングさせると、最初の (.+?) は a にのみマッチし、2番目は bcd にマッチします。定義上、演算子が貪欲であるかどうかは、正規表現が特定の文字列に全体としてマッチするかどうかには影響しません。バックトラック・アルゴリズムでは、非貪欲な演算子を単純に実装することができます。例えば、標準的なバックトラックの実装では、e?はまずeを使おうとし、次にeを使わないようにする。Thompsonのサブマッチトラッキングアルゴリズムは、非貪欲な演算子 に対応させることができる。

アサーション。伝統的な正規表現のメタキャラクタ ^ と $ は、その周りのテキストについてのアサーションと見なすことができます。は前の文字が改行 (あるいは文字列の先頭) であることを主張し、 $ は次の文字が改行 (あるいは文字列の末尾) であることを主張します。Perlはさらに、前の文字が英数字であるが次の文字が英数字でないこと、あるいはその逆を保証するワード・バウンダリー(word boundary \b)などのアサーションを追加した。(?=re) は現在の入力位置の後のテキストが re にマッチするが、実際には入力位置を進めないことを主張します。(?!re) も同様ですが、テキストが re にマッチしないことを主張します。ルックバインド アサーション (?<=re) および (?<!re) は同様ですが、現在の入力位置より前のテキストについて主張します。のような単純なアサーションは簡単です。
