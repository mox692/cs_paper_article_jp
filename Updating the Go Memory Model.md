# [日本語訳] Goのメモリモデルのアップデート -Updating the Go Memory Model-
> *Original Article*: https://research.swtch.com/gomm
> 
> This article is translated by [@mox692](https://twitter.com/mox692). Please contact me if any problem.

現在のGo言語のメモリモデルは2009年に書かれ、その後マイナーなアップデートが行われています。この投稿では、Goの全体的な哲学と現在のメモリモデルを再確認し、Goのメモリモデルに行うべきと私が考える比較的小さなアップデートについて概説します。  

この投稿は、以前の投稿「ハードウェアのメモリモデル」と「プログラミング言語のメモリモデル」で紹介した背景を前提としています。  

ここで紹介したアイデアに対するフィードバックを集めるために、GitHubのディスカッションを開始しました。そのフィードバックをもとに、今月末には正式なGoの提案書を作成する予定です。GitHubのディスカッションを使うこと自体、重要な変更に関するディスカッションを合理的に行う方法を見つけるための、ちょっとした実験なのです。

## Goのデザイン哲学
Goは実用的で効率的なシステムを構築するためのプログラミング環境であることを目指しています。小さなプロジェクトでは軽量に、大きなプロジェクトや大規模なエンジニアリングチームでは優雅にスケールアップすることを目指しています。Goは、特に通信を通じて、高いレベルで並行処理にアプローチすることを推奨しています。  
Goの最初の諺は「“Don't communicate by sharing memory. Share memory by communicating.”」(メモリ共有によってやりとりをするな. 通信することでメモリを共有せよ"です。もう1つの有名な諺は、"Clear is better than clever."(利口より奇才)です。  
つまり、Goは、微妙なコードを避けることによって、微妙なバグを避けることを推奨しています。Goは、理解しやすいプログラムだけでなく、理解しやすい言語と理解しやすいパッケージAPIも目指しています。複雑で微妙な言語機能やAPIはこの目標に反します。Tony Hoareが1980年のチューリング賞の講演で言ったように。  

> *私は、ソフトウェアの設計を構築する方法として、2つの方法があると結論付けています。一つは、明らかに欠陥がないように単純化する方法、もう一つは、明らかに欠陥がないように複雑化する方法です。前者は、自然界の複雑な現象の根底にある単純な物理法則を発見するのと同じような技術、献身、洞察力、さらにはひらめきが要求されます。また、物理的、論理的、技術的な制約によって制限された目標を受け入れ、相反する目標が達成できない場合は妥協する姿勢が必要です。*

これは、APIに関するGoの哲学とよく一致しています。Goが有用なプログラミング環境であることのもうひとつの側面は、最も一般的なプログラミングの間違いに対するセマンティクスがきちんと定義されていることです。この考え方は、ほとんど新しいものではありません。Tony Hoareが1972年に発表した「ソフトウェアの品質」チェックリストから引用しています。  


> *使い方が簡単であることはもちろん、誤用されにくいこと、プログラミングエラーに優しく、その発生を明確に示し、その効果が予測不可能にならないことなどが求められます。*

バグだらけのプログラムに対して、きちんとした意味づけを行うという常識は、期待するほど一般的ではありません。C/C++では、未定義の動作は、コンパイラライターの白紙委任状のようなもので、少しバグのあるプログラムを、これまで以上に興味深い方法で、まったく異なるバグのあるプログラムに変えてしまうように発展してきました。  
Goはこのようなアプローチをとらないので、「未定義の動作」は存在しません。特に、ヌルポインタの再参照、整数のオーバーフロー、意図しない無限ループなどのバグは、Goではすべて定義されたセマンティクスを持っています。


## 今日のGoのメモリモデル
Goのメモリモデルは、Goの全体的な哲学と一致する次のようなアドバイスから始まっています。

> *複数のゴルーチンが同時にアクセスするデータを修正するプログラムは、そのようなアクセスを直列化しなければなりません。アクセスを直列化するには、チャネル操作や、sync および sync/atomic パッケージのような同期化プリミティブでデータを保護する必要があります。*

これは今でも良いアドバイスです。このアドバイスは、他の言語がDRF-SCを推奨していることとも一致しています。データ競合をなくすために同期させれば、プログラムはあたかも連続的に整合しているかのように振る舞い、残りのメモリモデルを理解する必要はありません。  

このアドバイスの後、Goのメモリモデルでは、従来のhappen-beforeベースのレースリードとライトの仕様が定義されます。JavaやJavaScriptと同様に、Goの読み込みは、happened-beforeの順番で、まだ上書きされていない以前の書き込み、またはレース書き込みを観察することができ、そのような書き込みが1つだけあるように手配すると、特定の結果を強制します。

次に、メモリモデルは、ゴルーチン間のhappened-beforeエッジを確立する同期操作を定義します。この操作は通常のものですが、Goに特化した味付けがされています:  

* パッケージpがパッケージqをインポートしている場合、qのinit関数の終了はpのinit関数の開始より前に起こります。
* 関数main.mainの開始は、すべてのinit関数が終了した後である。
* 新しいgoroutineを開始する `go` ステートメントは、goroutineの実行が始まる前に起こります。
* あるチャネルへの送信は、そのチャネルからの受信が完了する前に行われます。
* チャネルのクローズは、チャネルがクローズされたためにゼロ値を返す受信の前に起こります。
* バッファされていないチャネルからの受信は、そのチャネルでの送信が完了する前に起こりす。
* 容量Cのチャネルでk番目の受信は、そのチャネルからのk+C番目の送信が完了する前に起こります。
* sync.Mutex または sync.RWMutex 変数 l と n < m において、 l.Unlock() の呼び出し n は、 l.Lock() の呼び出し m が戻る前に発生します。
* once.Do(f)からのf()の単一の呼び出しは、once.Do(f)の呼び出しが戻る前に起こる(戻る)。


このリストでは、sync/atomicやsyncパッケージの新しいAPIについての言及は特にありません。メモリモデルは不正確な同期の例で終わっています。不正確なコンパイルの例は含まれていません。

## Changes to Go's Memory Model
2009年、私たちがGoのメモリモデルを書こうとしたとき、Javaのメモリモデルは新しく改訂され、C/C++11のメモリモデルは最終的に決定されつつあるところでした。私たちは、C/C++11のモデルを採用することを強く勧められ、そのために行われたすべての作業を利用することにしました。  
しかし、それは危険なことです。この判断は、Java/C/C++のメモリモデルにおける非常に微妙な問題を詳述した論文が、その後10年以上にわたって発表されていることからも確認できます。プログラマやコンパイラを導くのに十分なメモリモデルを定義することは重要ですが、完全な形で（正しく）定義することは、最も優秀な研究者の理解をまだ超えているように思われます。Goは有用であるために必要な最小限のことを言い続ければ十分なのです。  
このセクションでは、私たちが行うべきと考える調整をリストアップします。先に述べたように、私はフィードバックを集めるためにGitHubのディスカッションを開始しました。

### Goの全体的なアプローチ
「賢くなるな」というアドバイスは重要であり、残るべきですが、happen-beforeの詳細に飛び込む前にGoの全体的なアプローチについてもっと説明する必要もあります。Goのモデルについて、C/C++の "DRF-SC or Catch Fire "であると主張するような、Goのアプローチに関する誤った要約を複数目にしました。誤読は理解できます。ドキュメントにはアプローチが何であるか書かれておらず、あまりにも短く（そして材料も微妙で）、人々は何があるかないかよりも、何を期待しているかを見てしまうのです。

追加するテキストは、次のようなものになるでしょう。

> *Goのメモリモデルは、言語の他の部分とほぼ同じ方法でアプローチされ、セマンティクスをシンプルで理解しやすく、有用なものにすることを目的としています。  
> データ競合とは、あるメモリ位置への書き込みと、その同じ位置への別の読み取りまたは書き込みが同時に発生することです。ただし、関係するすべてのアクセスが sync/atomic パッケージで提供されるアトミックなデータアクセスである場合を除きます。すでに述べたように、プログラマはデータ競合を避けるために適切な同期を使用することが強く推奨されます。データ競合がない場合、Goプログラムはあたかもすべてのゴルーチンが1つのプロセッサに多重化されているかのように振る舞います。この性質はDRF-SCと呼ばれることもあります。  
> データレースのないプログラムは、順次一貫した方法で実行されます。他のプログラミング言語は、データレースがあるプログラムに対して通常2つのアプローチのうち1つを取ります。  
> CやC++に代表されるように、データレースを含むプログラムは無効であり、コンパイラは任意の驚くべき方法でプログラムを破壊することができる。もうひとつは、JavaやJavaScriptに代表されるように、データレースを含むプログラムには定義されたセマンティクスがあり、レースがもたらしうる影響を制限し、プログラムの信頼性とデバッグをより容易にするものです。Goのアプローチは、この2つの間に位置する。データ競合のあるプログラムは、実装が競合を報告してプログラムを終了させる可能性があるという意味では無効です。しかし、そうでなければ、データ競合のあるプログラムは、限られた数の結果を伴う定義されたセマンティクスを持ち、誤ったプログラムの信頼性を高め、デバッグを容易にする。*
