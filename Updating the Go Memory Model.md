# [日本語訳] Goのメモリモデルのアップデート -Updating the Go Memory Model-
> *Original Article*: https://research.swtch.com/gomm
> 
> This article is translated by [@mox692](https://twitter.com/mox692). Please contact me if any problem.

現在のGo言語のメモリモデルは2009年に書かれ、その後マイナーなアップデートが行われています。この投稿では、Goの全体的な哲学と現在のメモリモデルを再確認し、Goのメモリモデルに行うべきと私が考える比較的小さなアップデートについて概説します。  

この投稿は、以前の投稿「ハードウェアのメモリモデル」と「プログラミング言語のメモリモデル」で紹介した背景を前提としています。  

ここで紹介したアイデアに対するフィードバックを集めるために、GitHubのディスカッションを開始しました。そのフィードバックをもとに、今月末には正式なGoの提案書を作成する予定です。GitHubのディスカッションを使うこと自体、重要な変更に関するディスカッションを合理的に行う方法を見つけるための、ちょっとした実験なのです。

## Goのデザイン哲学
Goは実用的で効率的なシステムを構築するためのプログラミング環境であることを目指しています。小さなプロジェクトでは軽量に、大きなプロジェクトや大規模なエンジニアリングチームでは優雅にスケールアップすることを目指しています。Goは、特に通信を通じて、高いレベルで並行処理にアプローチすることを推奨しています。  
Goの最初の諺は「“Don't communicate by sharing memory. Share memory by communicating.”」(メモリ共有によってやりとりをするな. 通信することでメモリを共有せよ"です。もう1つの有名な諺は、"Clear is better than clever."(利口より奇才)です。  
つまり、Goは、微妙なコードを避けることによって、微妙なバグを避けることを推奨しています。Goは、理解しやすいプログラムだけでなく、理解しやすい言語と理解しやすいパッケージAPIも目指しています。複雑で微妙な言語機能やAPIはこの目標に反します。Tony Hoareが1980年のチューリング賞の講演で言ったように。  

> *私は、ソフトウェアの設計を構築する方法として、2つの方法があると結論付けています。一つは、明らかに欠陥がないように単純化する方法、もう一つは、明らかに欠陥がないように複雑化する方法です。前者は、自然界の複雑な現象の根底にある単純な物理法則を発見するのと同じような技術、献身、洞察力、さらにはひらめきが要求されます。また、物理的、論理的、技術的な制約によって制限された目標を受け入れ、相反する目標が達成できない場合は妥協する姿勢が必要です。*

これは、APIに関するGoの哲学とよく一致しています。Goが有用なプログラミング環境であることのもうひとつの側面は、最も一般的なプログラミングの間違いに対するセマンティクスがきちんと定義されていることです。この考え方は、ほとんど新しいものではありません。Tony Hoareが1972年に発表した「ソフトウェアの品質」チェックリストから引用しています。  


> *使い方が簡単であることはもちろん、誤用されにくいこと、プログラミングエラーに優しく、その発生を明確に示し、その効果が予測不可能にならないことなどが求められます。*

バグだらけのプログラムに対して、きちんとした意味づけを行うという常識は、期待するほど一般的ではありません。C/C++では、未定義の動作は、コンパイラライターの白紙委任状のようなもので、少しバグのあるプログラムを、これまで以上に興味深い方法で、まったく異なるバグのあるプログラムに変えてしまうように発展してきました。  
Goはこのようなアプローチをとらないので、「未定義の動作」は存在しません。特に、ヌルポインタの再参照、整数のオーバーフロー、意図しない無限ループなどのバグは、Goではすべて定義されたセマンティクスを持っています。


## 今日のGoのメモリモデル
Goのメモリモデルは、Goの全体的な哲学と一致する次のようなアドバイスから始まっています。

> *複数のゴルーチンが同時にアクセスするデータを修正するプログラムは、そのようなアクセスを直列化しなければなりません。アクセスを直列化するには、チャネル操作や、sync および sync/atomic パッケージのような同期化プリミティブでデータを保護する必要があります。*

これは今でも良いアドバイスです。このアドバイスは、他の言語がDRF-SCを推奨していることとも一致しています。データ競合をなくすために同期させれば、プログラムはあたかも連続的に整合しているかのように振る舞い、残りのメモリモデルを理解する必要はありません。  

このアドバイスの後、Goのメモリモデルでは、従来のhappen-beforeベースのレースリードとライトの仕様が定義されます。JavaやJavaScriptと同様に、Goの読み込みは、happened-beforeの順番で、まだ上書きされていない以前の書き込み、またはレース書き込みを観察することができ、そのような書き込みが1つだけあるように手配すると、特定の結果を強制します。

次に、メモリモデルは、ゴルーチン間のhappened-beforeエッジを確立する同期操作を定義します。この操作は通常のものですが、Goに特化した味付けがされています:  

* パッケージpがパッケージqをインポートしている場合、qのinit関数の終了はpのinit関数の開始より前に起こります。
* 関数main.mainの開始は、すべてのinit関数が終了した後である。
* 新しいgoroutineを開始する `go` ステートメントは、goroutineの実行が始まる前に起こります。
* あるチャネルへの送信は、そのチャネルからの受信が完了する前に行われます。
* チャネルのクローズは、チャネルがクローズされたためにゼロ値を返す受信の前に起こります。
* バッファされていないチャネルからの受信は、そのチャネルでの送信が完了する前に起こりす。
* 容量Cのチャネルでk番目の受信は、そのチャネルからのk+C番目の送信が完了する前に起こります。
* sync.Mutex または sync.RWMutex 変数 l と n < m において、 l.Unlock() の呼び出し n は、 l.Lock() の呼び出し m が戻る前に発生します。
* once.Do(f)からのf()の単一の呼び出しは、once.Do(f)の呼び出しが戻る前に起こる(戻る)。


このリストでは、sync/atomicやsyncパッケージの新しいAPIについての言及は特にありません。メモリモデルは不正確な同期の例で終わっています。不正確なコンパイルの例は含まれていません。

## Changes to Go's Memory Model
2009年、私たちがGoのメモリモデルを書こうとしたとき、Javaのメモリモデルは新しく改訂され、C/C++11のメモリモデルは最終的に決定されつつあるところでした。私たちは、C/C++11のモデルを採用することを強く勧められ、そのために行われたすべての作業を利用することにしました。  
しかし、それは危険なことです。この判断は、Java/C/C++のメモリモデルにおける非常に微妙な問題を詳述した論文が、その後10年以上にわたって発表されていることからも確認できます。プログラマやコンパイラを導くのに十分なメモリモデルを定義することは重要ですが、完全な形で（正しく）定義することは、最も優秀な研究者の理解をまだ超えているように思われます。Goは有用であるために必要な最小限のことを言い続ければ十分なのです。  
このセクションでは、私たちが行うべきと考える調整をリストアップします。先に述べたように、私はフィードバックを集めるためにGitHubのディスカッションを開始しました。

### Goの全体的なアプローチ
「賢くなるな」というアドバイスは重要であり、残るべきですが、happen-beforeの詳細に飛び込む前にGoの全体的なアプローチについてもっと説明する必要もあります。Goのモデルについて、C/C++の "DRF-SC or Catch Fire "であると主張するような、Goのアプローチに関する誤った要約を複数目にしました。誤読は理解できます。ドキュメントにはアプローチが何であるか書かれておらず、あまりにも短く（そして材料も微妙で）、人々は何があるかないかよりも、何を期待しているかを見てしまうのです。

追加するテキストは、次のようなものになるでしょう。

> *Goのメモリモデルは、言語の他の部分とほぼ同じ方法でアプローチされ、セマンティクスをシンプルで理解しやすく、有用なものにすることを目的としています。  
> データ競合とは、あるメモリ位置への書き込みと、その同じ位置への別の読み取りまたは書き込みが同時に発生することです。ただし、関係するすべてのアクセスが sync/atomic パッケージで提供されるアトミックなデータアクセスである場合を除きます。すでに述べたように、プログラマはデータ競合を避けるために適切な同期を使用することが強く推奨されます。データ競合がない場合、Goプログラムはあたかもすべてのゴルーチンが1つのプロセッサに多重化されているかのように振る舞います。この性質はDRF-SCと呼ばれることもあります。  
> データレースのないプログラムは、順次一貫した方法で実行されます。他のプログラミング言語は、データレースがあるプログラムに対して通常2つのアプローチのうち1つを取ります。  
> CやC++に代表されるように、データレースを含むプログラムは無効であり、コンパイラは任意の驚くべき方法でプログラムを破壊することができる。もうひとつは、JavaやJavaScriptに代表されるように、データレースを含むプログラムには定義されたセマンティクスがあり、レースがもたらしうる影響を制限し、プログラムの信頼性とデバッグをより容易にするものです。Goのアプローチは、この2つの間に位置する。データ競合のあるプログラムは、実装が競合を報告してプログラムを終了させる可能性があるという意味では無効です。しかし、そうでなければ、データ競合のあるプログラムは、限られた数の結果を伴う定義されたセマンティクスを持ち、誤ったプログラムの信頼性を高め、デバッグを容易にする。*


## Document happens-before for sync libraries
メモリモデルが書かれてから、新しい API が sync パッケージに追加されました。それらをメモリモデルに追加する必要があります (issue #7948)。ありがたいことに、追加は簡単そうです。それらは以下のようなものだと思います。

For sync.Cond: BroadcastまたはSignalは、それがブロックを解除するWait呼び出しの戻り値の前に発生します。

sync.Mapの場合。Load、LoadAndDelete、LoadOrStoreは読み込み操作です。Delete、LoadAndDelete、Storeは、書き込み操作。LoadOrStoreは、loadedをfalseに設定して返すと、書き込み操作になる。書き込み操作は、書き込みの効果を観察する読み取り操作の前に行われます。

sync.Poolの場合。同様に、xを返すNewの呼び出しは、同じ値xを返すGetの呼び出しの前に起こります。

sync.WaitGroupの場合。Doneの呼び出しは、それがブロックを解除したWait呼び出しの戻り値の前に発生します。

これらのAPIを効果的に使用するためには、ユーザーはその保証を知る必要があります。したがって、説明のためにメモリモデル内にテキストを残すべきですが、パッケージsyncのdocコメントにも記載すべきです。これは、APIが確立した順序保証を文書化することの重要性を、サードパーティの同期プリミティブに示す例としても役立つだろう。

## Document happens-before for sync/atomic
アトミック操作がメモリモデルから抜けている。我々はそれを追加する必要があります (issue #5045)。と言うべきだと思います。

sync/atomic パッケージの API はまとめて「アトミック操作」であり、異なるゴルーチンの実行を同期させるために使用することができる。あるアトミック操作Aの効果がアトミック操作Bによって観測された場合、AはBより先に起こる。

これは、2013年にDmitri Vyukovが提案し、2016年に私が非公式に約束したことである。また、JavaのvolatileやC++のdefault atomicsと同じセマンティクスを持っています。

C/C++のメニューで言えば、アトミックの同期には逐次一貫か獲得/解放の2つの選択肢しかありません。(リラックスしたアトミックでは、happened-beforeエッジを作らないので、同期効果はない）。これらの選択は、第1に、複数の場所でのアトミック操作の相対的な順序を推論できることがどれほど重要であるか、第2に、acquire/releaseアトミックと比較してsequentially consistentアトミックがどれほど高価であるかということに帰着します。

第一に、複数個所のアトム演算の相対的な順序を推論することは、非常に重要です。以前の記事で、ロックフリーの高速パスを持つ条件変数を2つのアトミック変数で実装し、acquire/releaseアトミックで破壊する例を挙げました。このパターンは何度も登場します。たとえば、過去の sync.WaitGroup の実装では、wg.counter と wg.waiters という 2 つのアトミックな uint32 値のペアを使用しました。セマフォのGoランタイムの実装も、セマフォ値*addrとそれに対応するウェイターカウントroot.nwaitという2つの別々のアトミックワードに依存しています。他にもあります。順次一貫したセマンティクスがない場合（つまり、獲得/解放セマンティクスを採用する場合）、人々はまだこのようなコードを書くでしょう。

根本的な問題は、acquire/releaseアトミックを使ってプログラムをデータレースフリーにしても、アトミック自体がそうではないので、逐次一貫した振る舞いをするプログラムにはならない、ということです。つまり、このようなプログラムはDRF-SCを提供しない。このため、このようなプログラムは推論が非常に難しく、したがって正しく記述することも困難です。

2つ目の点については、先の記事で述べたように、ハードウェア設計者が順次一貫したアトミックを直接サポートするようになりつつあることです。例えば、ARMv8では、逐次一貫アトミックを実装するためのldar命令とstlr命令が追加されており、これらはacquire/releaseアトミックの推奨実装でもあります。sync/atomicにacquire/releaseセマンティクスを採用すると、ARMv8で書かれたプログラムでは、とにかく順次一貫性が得られるようになります。このため、より強い順序に依存するプログラムが、弱いプラットフォームで誤って壊れてしまうことは間違いないでしょう。もし、acquire/releaseとsequential consistent atomicsの違いが、レースウィンドウが小さいために、実際には観察することが困難であれば、これは単一のアーキテクチャでさえ起こるかもしれません。

順次一貫したアトミックはより有用であり、いくつかのチップはすでにこの2つのレベルのギャップを完全に埋めています。順次一貫したアトミックはより有用であり、いくつかのチップはすでに2つのレベルの間のギャップを完全に埋めており、おそらく他のチップも同じことを行うでしょう。

最小限の、理解しやすいAPIを持つというGoの全体的な哲学と同じことを考慮すると、acquire/releaseを追加の、並列のAPIセットとして提供することに反対します。最も理解しやすく、最も有用で、最も誤用されないアトミック操作のセットだけを提供するのが最善だと思われます。

もう一つの可能性は、アトミック操作の代わりに生のバリアーを提供することです。(もちろんC++は両方を提供しています。) バリアは、期待することがあまり明確でなく、アーキテクチャに依存するという欠点があります。Hans Boehmのページ "Why atomics have integrated ordering constraints "では、バリアの代わりにアトミックを提供する論拠が示されている（彼はフェンスという言葉を使っている）。一般に、アトミックはフェンスよりはるかにわかりやすいし、今日すでにアトミック操作を提供しているので、簡単に取り除くことはできない。2つの機構を持つより1つの機構を持つ方が良い。

## Maybe: Add a typed API to sync/atomic
上記の定義によると、あるメモリの一部を複数のゴルーチンが他の同期を取らずに同時にアクセスする必要がある場合、競合を排除する唯一の方法は、すべてのアクセスにアトミックが使用されるようにすることです。一部のアクセスだけアトミックにすればよいというものではありません。例えば、アトミックな読み書きと同時に非アトミックな書 き込みを行った場合もレースとなりますし、アトミックな読み書きと同時にアトミックな書 き込みを行った場合もレースとなります。

したがって、ある値をアトミックでアクセスすべきかどうかは、その値の特性であり、特定のアクセスの特性ではありません。このため、ほとんどの言語では、Javaのvolatile intやC++のatomic<int>のように、この情報を型システムに置いています。Goの現在のAPIはそうではありません。つまり、正しい使い方をするには、構造体のどのフィールドやグローバル変数がアトミックなAPIを使ってのみアクセスされることが期待されているか、注意深くアノテーションする必要があります。

プログラムの正しさを向上させるために、私は、現在の atomic.Value に類似した、型付きアトム値のセットを定義すべきだと考え始めています。Bool、Int、Uint、Int32、Uint32、Int64、Uint64、および Uintptr です。Value と同様に、これらは CompareAndSwap、Load、Store、および Swap メソッドを持つことになります。例えば

```
type Int32 struct { v int32 }

func (i *Int32) Add(delta int32) int32 {
	return AddInt32(&i.v, delta)
}

func (i *Int32) CompareAndSwap(old, new int32) (swapped bool) {
	return CompareAndSwapInt32(&i.v, old, new)
}

func (i *Int32) Load() int32 {
	return LoadInt32(&i.v)
}

func (i *Int32) Store(v int32) {
	return StoreInt32(&i.v, v)
}

func (i *Int32) Swap(new int32) (old int32) {
	return SwapInt32(&i.v, new)
}

```

Boolをリストに加えたのは、Go標準ライブラリで何度もアトミック整数からアトミックブーリアンを構築してきたからです（未エクスポートのAPIで）。明らかにニーズがあるのです。

また、来るべきジェネリック サポートを利用して、型付けされ、その API にパッケージ unsafe がない、アトミック ポインタの API を定義することもできます。

```
type Pointer[T any] struct { v *T }

func (p *Pointer[T]) CompareAndSwap(old, new *T) (swapped bool) {
	return CompareAndSwapPointer(... lots of unsafe ...)
}
```

(そして、そのように。) 明らかな提案に答えるなら、Bool や Int などを別々の型として導入することを避けさせる、単一の atomic.Atomic[T] を提供するだけのためにジェネリックスを使用するクリーンな方法は、少なくともコンパイラで特別なケースがない限り見当たりません。それはそれでいいのです。


## Maybe: Add unsynchronized atomics
他のすべてのモダンなプログラミング言語は、プログラムを同期させないが、無効にもしない（データレースとしてカウントしない）メモリの同時読み取りと書き込みを行う方法を提供しています。C、C++、Rust、Swiftには、relaxed atomicsがあります。JavaにはVarHandleの「プレーン」モードがある。JavaScriptはSharedArrayBuffer（唯一の共有メモリ）への非アトミックアクセスがあります。Goにはこれを実現する方法がありません。もしかしたら、そうすべきかもしれません。どうでしょう。

非同期のアトミックな読み書きを追加したい場合は、型付きアトミックにUnsyncAdd、UnsyncCompareAndSwap、UnsyncLoad、UnsyncStore、およびUnsyncSwapメソッドを追加することが可能です。これらに "unsync "と名付けることで、"relaxed "という名称が持ついくつかの問題を回避することができます。まず、「acquire/releaseはsequential consistencyよりも緩やかなメモリ順序である」というように、relaxedを相対的な比較として使う人がいる。これは用語の適切な使用法ではないと主張することもできますが、実際に起こっていることです。第二に、より重要なこととして、これらの操作の重要な詳細は、操作自体のメモリ順序ではなく、プログラムの残りの部分の同期に影響を与えないという事実である。メモリモデルの専門家でない人がUnsyncLoadを見れば、同期がないことがわかるはずですが、RelaxedLoadではおそらくわからないと思います。また、Unsyncは一見するとUnsafeのように見えるのもいいところです。

APIはさておき、本当の問題はこれらを追加するかどうかだ。非同期アトムを提供するための通常の議論は、特定のデータ構造における高速パスのパフォーマンスにとって本当に重要であるというものです。私の一般的な印象では、x86以外のアーキテクチャで最も重要だと思いますが、これを裏付けるデータがあるわけではありません。非同期アトムを提供しないことは、これらのアーキテクチャにペナルティを課すことになると主張することができます。

非同期アトミックを提供することに反対する議論として考えられるのは、x86では、コンパイラの並べ替えの可能性を無視すると、非同期アトミックがacquire/releaseアトミックと区別がつかないということです。したがって、x86上でしか動作しないコードを書くために悪用される可能性があります。このような裏技は、x86のメモリモデルではなく、実際のメモリモデルを実装しているレースディテクタには通用しないという反論があります。

今日、私たちが持っている証拠の欠如により、このAPIを追加することは正当化されないでしょう。もし、このAPIを追加すべきだと強く思う人がいれば、その根拠として、（1）プログラマが書く必要のあるコードに一般的に適用できること、（2）広く使われているシステムで非同期アトミックを使用することにより性能が大幅に向上すること、の両方を集めてください。(Go以外の言語のプログラムを用いて示すのも良いだろう）。



