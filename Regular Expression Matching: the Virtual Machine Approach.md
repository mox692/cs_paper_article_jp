# [日本語訳]正規表現マッチング: VMによるアプローチ -Regular Expression Matching: the Virtual Machine Approach- (By Russ Cox)
> *Original Article*: https://swtch.com/~rsc/regexp/regexp2.html
> 
> This article is translated by [@mox692](https://twitter.com/mox692). Please contact me if any problem.

* 記事中のソースコードは[こちら](https://swtch.com/~rsc/regexp/)から参照できます.


## Introduction
最も広く使われているバイトコードインタプリタまたは仮想マシンを挙げてください。サンのJVM？AdobeのFlash? .NETとMono?Perl？Python？PHP？これらはすべて確かに人気があるが、それらをすべて合わせたよりも広く使われているものがある。そのバイトコードインタプリタとは、ヘンリー・スペンサーの正規表現ライブラリとその多くの子孫たちである。

それは awk や egrep (そして今ではほとんどの grep) で使われている最悪の場合の線形時間 NFA および DFA ベースの戦略と、ed, sed, Perl, PCRE, Python など他のほとんどの場所で使われている最悪の場合の指数時間バックトラックの戦略です。

この記事では、.NET と Mono が CLI バイトコードにコンパイルされたプログラムを実行する仮想マシンを実装する異なる方法であるように、テキストマッチングバイトコードにコンパイルされた正規表現を実行する仮想マシンを実装する2つの異なる方法として2つの戦略を紹介します。

正規表現マッチングを特殊なマシンの実行と見なすことで、新しいマシン命令を追加（実装）するだけで、新しい機能を追加することができるようになります。特に、正規表現のサブマッチ命令を追加することで、aabbbbに対して(a+)(b+)をマッチングした後、括弧付きの(a+)(しばしば \1 または $1 と呼ばれる)がaaにマッチしたこと、(b+)がbbbbにマッチしたことをプログラムが発見できるようにすることができるのです。サブマッチはバックトラックVMでも非バックトラックVMでも実装可能である。(これを行うコードは1985年までさかのぼりますが、この記事が最初に書かれた説明だと思います)。

## 正規表現VM
まず始めに、正規表現仮想マシン(Java VMを想像してください)を定義します。VMは1つ以上のスレッドを実行し、それぞれが正規表現プログラム（正規表現命令のリスト）を実行します。各スレッドは実行中、プログラムカウンタ（PC）と文字列ポインタ（SP）という2つのレジスタを保持します。

正規表現VMにおける命令は下記のようになります:

* *char c* : SPが指す文字がcでない場合、このスレッドを停止します。そうでなければ、SPを次の文字に進め、PCを次の命令に進める。
* *match* : matchした場合、このスレッドを停止する。
* *jmp* :  x にある命令にジャンプする（その後PC がxを指すように設定する）。
* *split x, y* : スプリット実行：x と y の両方で継続する。一方のスレッドはPC xで継続し、もう一方のスレッドはPC yで継続する（両位置への同時ジャンプのようなもの）。

VMは、PCがプログラムの先頭を、SPが入力文字列の先頭を指している1つのスレッドが実行されている状態からスタートします。スレッドを実行するには、VMはスレッドのPCが指す命令を実行し、その命令を実行するとスレッドのPCは次に実行する命令を指すように変化する。ある命令（failed charまたはmatch）がスレッドを停止させるまで繰り返す。正規表現は、いずれかのスレッドがマッチを見つけた場合、文字列にマッチします。
正規表現をバイトコードにコンパイルすることは、正規表現の形式に応じて再帰的に進行します。正規表現には、aのような1文字、e1e2という連結、e1|e2という交互、e?（0または1）、e*（0または複数）、e+（1または複数）の繰り返しの4種類があることを前回の記事で思い出してください。連結は、2つの部分式のコンパイル形式を連結する。交替式は、どちらかの選択が成功するように分割を使用します。ゼロまたは1の繰り返し e? は、空文字列を含む交互表現のようにコンパイルするために分割を使用します。ゼロ以上の繰り返し e* と1回以上の繰り返し e+ は、e にマッチするか繰り返しを抜けるかを選択するためにスプリットを使用します。  
実際のバイトコードは次のようになります

<img width="381" alt="スクリーンショット 2022-05-29 19 34 36" src="https://user-images.githubusercontent.com/55653825/170863677-48d88728-00d3-48b4-8548-ed984fd4b251.png">  

正規表現全体がコンパイルされると、生成されたコードは最後のマッチング命令で終了する。

例として、正規表現 a+b+ は次のようにコンパイルされます。

```
0   char a
1   split 0, 2
2   char b
3   split 2, 4
4   match

```

aabという入力に対して上記の正規表現VMを実行する場合、このようにプログラムを実行することができます。  

<img width="630" alt="スクリーンショット 2022-05-29 19 36 41" src="https://user-images.githubusercontent.com/55653825/170863753-6dcf298f-b371-497f-8114-7967f9394cfa.png">

この例では、現在のスレッドが終了するまで新しいスレッドの実行を待ち、作成された順番にスレッドを実行します（古いものから）。これはVMの仕様では要求されていません。スレッドをスケジュールするのは実装次第です。他の実装では、スレッドを別の順番で実行したり、スレッドの実行をインターリーブしたりすることもできます。
