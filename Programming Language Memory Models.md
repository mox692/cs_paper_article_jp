# [日本語訳] プログラミング言語のメモリモデル -Programming Language Memory Models-
> *Original Article*: https://research.swtch.com/plmm
> 
> This article is translated by [@mox692](https://twitter.com/mox692). Please contact me if any problem.

プログラミング言語のメモリモデルは、並列プログラムがスレッド間でメモリを共有するために、どのような動作に依存できるかという問題に答えるものである。例えば，x と done がゼロから始まる C 言語によるプログラムを考えてみよう．

<p align="center">
<img width="423" alt="スクリーンショット 2022-09-07 19 15 09" src="https://user-images.githubusercontent.com/55653825/188853749-bce53231-0e73-49b6-b7ab-99061119ca4f.png">
</p>

このプログラムは，メッセージの受信準備が整ったことを示す信号として done を使い，x のメッセージをスレッド 1 からスレッド 2 に送ろうとするものである．スレッド1とスレッド2がそれぞれ専用のプロセッサで実行され、両方が完了するまで実行された場合、このプログラムは意図したとおりに終了し、1を印刷することが保証されているのだろうか？このような疑問に答えるのが、プログラミング言語のメモリモデルである。

プログラミング言語によって詳細は異なりますが、C、C++、Go、Java、JavaScript、Rust、Swiftなど、基本的に現代のすべてのマルチスレッド言語について、いくつかの一般的な回答が当てはまります。

* まず、x と done が普通の変数である場合、スレッド 2 のループは決して止まらない可能性があります。一般的なコンパイラの最適化は、変数の最初の使用時にレジスタにロードし、その後、その変数への将来のアクセスのために、できるだけ長くそのレジスタを再利用することです。もしスレッド2がdoneをスレッド1の実行前にレジスタにコピーすると、スレッド1が後でdoneを変更したことに気づかず、ループ全体にわたってそのレジスタを使い続けるかもしれません。
* 第二に、たとえスレッド 2 のループが停止しても、done == 1 を観察して、x が 0 であると表示するかもしれません。コンパイラはしばしば、最適化のヒューリスティックや、コード生成中にハッシュテーブルや他の中間データ構造をトラバースする方法に基づいてプログラムの読み取りと書き込みの順序を変更します。スレッド 1 用のコンパイルされたコードは x を done の前ではなく後に書き込んでしまうかもしれませんし、スレッド 2 用のコンパイルされたコードは x をループの前に読み込んでしまうかもしれません。

このプログラムがいかに壊れているかを考えると、どのように修正するかが明らかな問題です。

最近の言語では、アトミック変数やアトミック操作という形で、プログラムがスレッドを同期させるための特別な機能が提供されています。doneをアトム変数にすれば（アトム操作を採用している言語ではアトム操作で）、プログラムの終了とprint1が保証される。doneをアトミックにすると、いろいろな効果があります。

* スレッド 1 のコンパイルされたコードは、done への書き込みが可視になる前に x への書き込みが完了し、他のスレッドから可視であることを確認する必要があります。
* スレッド 2 用のコンパイル済みコードはループの各反復で done を (再) 読み込まなければなりません。
* スレッド 2 用のコンパイル済みコードは、done からの読み込みの後に x から読み込まなければなりません。
* コンパイルされたコードは、これらの問題のいずれかを再導入する可能性のあるハードウェア最適化を無効にするために必要なことは何でもしなければなりません。

元のプログラムでは、コンパイラがコードを並べ替えた後、スレッド1がxを書き、同時にスレッド2がそれを読むことができました。これはデータレースである。修正後のプログラムでは、アトム変数doneがxへのアクセスを同期させる役割を果たし、スレッド1がxを書き込んでいるときにスレッド2がそれを読むことは不可能になった。このプログラムでは、データレースが発生しない。一般に、現代の言語では、データレースフリーのプログラムは、あたかも異なるスレッドの操作を任意に、しかし順序を変えずに単一のプロセッサにインターリーブしたように、常に逐次一貫した方法で実行されることが保証されている。余談だが、このアトミック変数やアトミック演算は「シンクロナイジング・アトミック」と呼ぶのが適切であろう。確かにデータベース的にはアトミックな操作であり、同時に読み書きを行っても、ある順番で順次実行されているかのように振る舞う。しかし、アトミックがプログラムの他の部分を同期させ、アトミックでないデータ上の競合を排除する方法を提供することはさらに重要です。標準的な用語は「アトミック」なので、この記事でもそれを使っています。プログラミング言語のメモリモデルは、プログラマとコンパイラの間の契約として、何が必要かを詳細に規定するものです。プログラミング言語のメモリモデルは、プログラマとコンパイラの間で交わされる契約書のようなものである。現在でも、2次的な質問については、言語間で大きな違いがある。

* アトム変数自体の順序保証は？
* ある変数にアトミック操作と非アトミック操作の両方がアクセスできますか？
* アトミック以外の同期機構はありますか？
* 同期をとらないアトミック演算はありますか？
* 競合があるプログラムは全く保証されないのですか？ 

この記事では、いくつかの前置きをした後、さまざまな言語がこれらの問題や関連する問題にどのように答えているか、またそこに到達するまでにどのような経路をたどってきたかを調べます。また、この投稿では、何が有効で何が有効でないかをまだ非常によく学んでいることを強調するために、その過程で多くの失敗があったことを強調しています。

## Hardware, Litmus Tests, Happens Before, and DRF-SC

特定の言語の詳細に触れる前に、ハードウェアのメモリモデルから得た教訓を簡単にまとめておきます。アーキテクチャが異なると、命令を並べ替えられる量が異なるため、複数のプロセッサで並列に実行するコードは、アーキテクチャによって異なる結果が得られる可能性があります。この場合、異なるプロセッサで実行されるプログラムは、あたかも1つのプロセッサにある順番でインターリーブされたかのように振る舞わなければなりません。このモデルは、開発者が推論するのがはるかに簡単ですが、保証を弱めることで性能が向上するため、現在では重要なアーキテクチャが提供していません。異なるメモリモデルを比較して完全に一般的な発言をするのは困難です。異なるメモリモデルを比較して完全に一般的な発言をすることは困難です。その代わりに、リトマス試験と呼ばれる特定のテストケースに焦点を当てることが有効です。あるリトマス試験で2つのメモリモデルが異なる動作をした場合、それは両者が異なることを証明し、少なくともその試験ケースについて、一方が他方より弱いか強いかを確認するのに役立つのが一般的です。例えば、先に調べたプログラムのリトマス試験形式は次のとおりです。

<p align="center">
<img width="582" alt="スクリーンショット 2022-09-07 19 25 46" src="https://user-images.githubusercontent.com/55653825/188856136-67aac9c3-4cc3-4bb4-b8e4-9941eb0a648c.png">
</p>

前の投稿と同様に、すべての例はすべての共有変数にゼロが設定されて始まるものとしています。rNという名前は、レジスタや関数ローカル変数のようなプライベートなストレージを表し、xやyのような他の名前は、個別の共有（グローバル）変数を表します。実行終了時にレジスタの特定の設定が可能かどうかを問う。r1 = 1, r2 = 0という結果は、元のプログラムのスレッド2がループを終了し（doneはy）、その後0を表示することに対応します。アセンブリ言語版では、0を表示することはx86では不可能ですが、ARMやPOWERのようなより緩やかなアーキテクチャでは、プロセッサ自体の順序変更最適化により可能です。最近の言語では、コンパイル時に並べ替えを行うことができるため、ハードウェアがどうであれ、このような結果を得ることができます。先に述べたように、現在のプロセッサは、順次一貫性を保証する代わりに、「データレースフリー順次一貫性」またはDRF-SC（SC-DRFとも書くことがあります）と呼ばれる特性を保証します。DRF-SCを保証するシステムには、同期命令と呼ばれる、異なるプロセッサ（スレッド）を連携させるための特定の命令を定義する必要がある。例えば、あるプログラムを2つのスレッドで短時間実行した場合の図を示します。

<p align="center">
<img width="587" alt="スクリーンショット 2022-09-07 19 27 58" src="https://user-images.githubusercontent.com/55653825/188856431-da0275d6-58f4-4539-b92b-88d0c8160231.png">
</p>

このプログラムも前回の記事で見ました。スレッド1とスレッド2が同期命令S(a)を実行します。このプログラムの特定の実行では、2つのS(a)命令はスレッド1からスレッド2へのhappen-before関係を確立するので、スレッド1のW(x)はスレッド2のR(x)の前に起こる。happen-beforeによって順番付けされていない異なるプロセッサ上の二つのイベントは、同じ瞬間に発生するかもしれない：正確な順番は不明である。正確な順序は不明である。我々はこれらを同時実行と呼ぶ。データレースとは、ある変数への書き込みが、その同じ変数の読み出しまたは別の書き込みと同時に実行されることです。DRF-SCを提供するプロセッサは（最近ではすべてのプロセッサが）、データレースのないプログラムは、あたかも順次一貫したアーキテクチャで実行されているかのように動作することを保証している。DRF-SCは、先に見たように、現代言語が高水準言語で正しいマルチスレッドプログラムを書くために採用した基本的な保証でもあるのです。

## Compilers and Optimizations
コンパイラが最終的な実行コードを生成する過程で、入力プログラムの演算を並べ替え る可能性があることを何度か述べました。一般に、コンパイラは通常のメモリへの読み書きをほぼ任意に並べ替えることができると考えられていますが、並べ替えによってコードのシングルスレッド実行が変化しないことが条件です。例えば、次のようなプログラムを考えてみましょう。

<p align="center">
<img width="149" alt="スクリーンショット 2022-09-07 19 29 56" src="https://user-images.githubusercontent.com/55653825/188856768-25d95b79-5212-41c7-970d-30f136e5dc6e.png">
</p>

x、y、zはすべて異なる変数なので、この4つの文はコンパイラが最適と考える任意の順序で実行することが可能です。ハードウェアの記事では、ARM/POWERアーキテクチャが保証するものの例として、コヒーレンスについて見てきました：

<p align="center">
<img width="595" alt="スクリーンショット 2022-09-07 19 30 39" src="https://user-images.githubusercontent.com/55653825/188856920-0fdb16ae-1b4c-4b79-b6bc-424ecdb2e2b3.png">
</p>

最近のハードウェアはすべてコヒーレンスを保証しており、これは単一のメモリ位置に対する操作の順序的整合性と見なすこともできます。このプログラムでは、どちらかの書き込みがもう一方を上書きしなければならず、システム全体がどちらがどちらかについて合意しなければならない。しかし、コンパイル時にプログラムの順序を入れ替えるため、現代の言語ではコヒーレンスを提供することすらできないことが判明した。 例えば、コンパイラがスレッド4で2つの読み出し命令を並べ替えたとすると、

<p align="center">
<img width="484" alt="スクリーンショット 2022-09-07 19 36 30" src="https://user-images.githubusercontent.com/55653825/188857945-0115be20-fd2b-49db-baf0-7270ef872b42.png">
</p>

結果、r1 = 1、r2 = 2、r3 = 2、r4 = 1となるが、これらは、組立プログラムでは不可能だったが高級言語で可能だったのだ。このように、プログラミング言語のメモリモデルは、最も緩やかなハードウェアのメモリモデルよりも弱いものばかりです。しかし、いくつかの保証はあります。DRF-SCは、シングルスレッド・コードでは有効であった最適化であっても、新たな読み取りや書き込みを発生させる最適化を認めないものである。例えば、次のコードを考えてみよう： 

```
if(c) {
	x++;
} else {
	... lots of code ...
}
```

elseに多くのコードがあり、if本文にはx++しかないif文がある。分岐を少なくして、if本体を完全になくす方が安上がりかもしれない。if の前に x++ を実行し、間違っていたら大きな else 本体の x-- で調整すればいいのです。つまり、コンパイラはそのコードを次のように書き換えることを考えるかもしれない：

```
x++;
if(!c) {
	x--;
	... lots of code ...
}
```

これは安全なコンパイラの最適化なのだろうか？シングルスレッド・プログラムでは、イエスです。この例は、Hans Boehmが2004年に発表した論文「Threads Cannot Be Implemented As a Library」の中の一説に由来しており、言語はマルチスレッド実行のセマンティクスについて黙ってはいられないと主張している。プログラミング言語のメモリモデルは、どの最適化が許され、どの最適化が許されないかという質問に正確に答える試みである。プログラミング言語のメモリモデルは、どのような最適化が許され、どのような最適化が許されないかという問題に正確に答えようとする試みです。過去数十年にわたりこのモデルを記述しようとした歴史を調べることで、何がうまくいき、何がうまくいかなかったかを知り、物事がどこへ向かっているのかを知ることができるのです。

## Original Java Memory Model (1996)
Javaは、マルチスレッドプログラムに対して保証する内容を書き出そうとした最初の主流言語です。この言語にはミューテックスが含まれ、それが意味するメモリ順序の要件が定義されています。また、「揮発性」アトミック変数も含めました。揮発性変数のすべての読み込みと書き込みは、メインメモリで直接プログラム順に実行することが求められ、揮発性変数に対する操作が順次一貫した方法で動作するようにしました。最後に、Javaはデータレースがあるプログラムの動作も規定した（あるいは少なくとも規定しようとした）。その1つが、通常の変数に対するコヒーレンスの形式を義務付けることであり、これについては後ほど詳しく検討します。残念ながら、この試みはJava言語仕様の初版（1996年）において、少なくとも2つの重大な欠陥があった。これらは、後知恵で、すでに述べた前置きを使えば簡単に説明できます。当時は、それほど明白ではありませんでした。


### Atomics need to synchronize
第一の欠点は、揮発性の原子変数が非同期であるため、プログラムの他の部分の競合を排除するのに役立たないことです。上で見たメッセージパッシングプログラムのJava版は次のようになります。

<p align="center">
<img width="362" alt="スクリーンショット 2022-09-07 19 49 23" src="https://user-images.githubusercontent.com/55653825/188860502-ce37ca82-2d62-4262-a674-3b6888d28102.png">
</p>

doneはvolatileと宣言されているので、ループの終了が保証されます。コンパイラはdoneをレジスタにキャッシュして無限ループを引き起こすことはできません。しかし、プログラムが1を表示することは保証されていない。コンパイラはxとdoneへのアクセスを並べ替えることを禁止していませんし、ハードウェアが同じことをするのを禁止する必要もありません。Javaのvolatileは非同期のアトミックなので、それを使って新しい同期プリミティブを構築することはできません。その意味で、オリジナルのJavaのメモリモデルは弱すぎたのです。

### Coherence is incompatible with compiler optimizations
スレッドがメモリ位置の新しい値を読み取ると、古い値を読み取るように見えることはない、というコヒーレンスを強制することで、コンパイラの基本的な最適化を阻害していました。先に、読み込みの順番を変更するとコヒーレンシが失われることを説明しましたが、「読み込みの順番を変更しなければいい」と思うかもしれません。ここでは、別の最適化、すなわち共通部分式の削除によってコヒーレンシが失われる可能性のある、より微妙な方法を説明します。
次のようなJavaプログラムを考えてみましょう。

<p align="center">
<img width="356" alt="スクリーンショット 2022-09-07 19 51 45" src="https://user-images.githubusercontent.com/55653825/188860950-119ea769-74a0-41ca-a0e4-729a9bc90c86.png">
</p>

しかし、もしpとqが同じオブジェクトを指していて、iとjの読み込みの間に別のスレッドがp.xに書き込んだとしたら、kに古い値iを再利用するとコヒーレンスに違反することになります。冗長な読み出しを最適化できないため、ほとんどのコンパイラーは、生成されるコードが遅くなります。ハードウェアは動的最適化を適用できるため、コヒーレンスを提供することはコンパイラーよりも簡単です。これに対し、コンパイラは静的な最適化しか行えないため、どのようなアドレスや値が使われても正しい命令列をあらかじめ書いておかなければならない。この例では、コンパイラは、pとqがたまたま同じオブジェクトを指しているかどうかによって、何が起こるかを簡単に変えることができない。少なくとも、両方の可能性に対応するコードを書き出さない限り、時間と空間のオーバーヘッドが大きくなる。コンパイラは、メモリ位置間のエイリアシングの可能性について不完全な知識を持っているため、実際にコヒーレンスを提供するには、基本的な最適化をあきらめなければなりません。Bill Pugh氏は、1999年の論文 "Fixing the Java Memory Model" でこの問題やその他の問題を指摘しています。

## New Java Memory Model (2004)
このような問題があり、またオリジナルのJava Memory Modelは専門家でも理解するのが難しかったため、Pugh氏らはJavaの新しいメモリモデルを定義する取り組みを開始した。そのモデルはJSR-133となり、2004年にリリースされたJava 5.0に採用された。標準的な参考文献は、Jeremy Manson、Bill Pugh、Sarita Adveによる「The Java Memory Model」（2005年）、およびMansonの博士論文に詳細が記載されています。新しいモデルは、DRF-SCアプローチに従っています。データレースフリーのJavaプログラムは、逐次一貫した方法で実行されることが保証されている。

### Synchronizing atomics and other operations
あるスレッドがアトミックでない変数を書き込むとき、他のスレッドがそれを読み書きしているときに同時に書き込まないようにするために、プログラマはhappened-beforeエッジを確立する同期操作を必要とします。Javaでは、主な同期操作は以下の通りです。

* スレッドの生成は、そのスレッドでの最初の動作の前に行われる。
* mutex mのロック解除は、その後にmをロックするよりも前に行われる。
* volatile変数vへの書き込みは、それに続くvの読み出しの前に行われる。
  
subsequent "とはどういう意味ですか？Javaでは、すべてのロック、アンロック、揮発性変数へのアクセスは、あたかも順次一貫したインターリーブで発生したかのように振る舞い、プログラム全体におけるこれらの操作の合計順を与える、と定義しています。「後続 "とは、その総順序の中で後になることを意味します。つまり、ロック、アンロック、揮発性変数へのアクセスの総順序がsubsequentの意味を定義し、次にsubsequentが特定の実行によってどのhappens-before edgeが作られるかを定義し、そしてhappens-before edgeがその特定の実行にデータレースがあるかどうかを定義します。レースがない場合、その実行は順次一貫した方法で動作する。

揮発性アクセスは、ある総順序で行動しなければならないということは、ストアバッファのリトマス試験において、r1 = 0とr2 = 0で終わってはいけないということです。

<p align="center">
<img width="329" alt="スクリーンショット 2022-09-07 19 56 17" src="https://user-images.githubusercontent.com/55653825/188861802-e1f9013a-9d9f-4b38-8b67-d50e51a6e152.png">
</p>

Javaでは、揮発性変数xとyに対して、読み込みと書き込みの順序を変えることはできません。1つの書き込みは2番目に来る必要があり、2番目の書き込みに続く読み込みは最初の書き込みを見なければなりません。ここで重要な、しかし微妙なポイントがあります。それは、すべての同期操作の合計順序は、happens-beforeの関係とは別であるということです。プログラム中のすべてのロック、アンロック、揮発性変数へのアクセスの間に、一方向にhappens-beforeのエッジが存在するわけではありません。例えば、異なるミューテックスのロックとアンロック、異なる変数の揮発性アクセスは、これらの操作が集合的にあたかも1つの順次一貫したインターリーブに従って動作しなければならないにもかかわらず、それらの間にhappens-beforeエッジを持たない。

### Semantics for racy programs
DRF-SCは、データレースのないプログラムに対してのみ、順次一貫した動作を保証しています。新しいJavaのメモリモデルは、オリジナルと同様に、いくつかの理由から、レースがあるプログラムの動作を定義しました。

Java の一般的なセキュリティと安全性の保証をサポートするため。
プログラマーが間違いを見つけやすくするため。
レースによる被害が限定されるため、攻撃者が問題を悪用しにくくなる。
プログラマが自分のプログラムが何をするのかが明確になる。
新しいモデルでは、コヒーレンスに頼るのではなく、happens-before関係（プログラムがレースを起こすかどうかを決めるためにすでに使われている）を再利用して、レースの読み書きの結果を決めるようにしました。

Java特有の規則として、ワードサイズ以下の変数では、変数（またはフィールド）xの読み出しは、xへの1回の書き込みによって格納された値を見なければならない。xへの書き込みは、rがwより前に起こらなければ読み出しrによって観察できる。つまり、rはrより前に起こった書き込み（ただしrより前に上書きされていない書き込み）を観察でき、rと競合する書き込みを観察できる。

このようにhappen-beforeを使用し、新しいhappen-beforeエッジを確立できる同期アトミック（volatile）と組み合わせることで、オリジナルのJavaメモリモデルに対して大きな改善がなされました。プログラマにとってより有用な保証となり、コンパイラによる多くの重要な最適化が決定的に可能になったのです。この成果は、今日でもJavaのメモリモデルとして採用されています。つまり、レイシープログラムのセマンティクスを定義しようとすると、このhappen-beforeの使い方には問題があるのです。

## Happens-before does not rule out incoherence
プログラムの意味論を定義するためのhappen-beforeの最初の問題は、首尾一貫性に関係する（またか！）。(次の例は、Jaroslav Ševčík と David Aspinall の論文 "On the Validity of Program Transformations in the Java Memory Model" (2007) から引用したものです).

ここに3つのスレッドを持つプログラムがある。スレッド1とスレッド2がスレッド3の開始前に終了することが分かっているとします。

<p align="center">
<img width="351" alt="スクリーンショット 2022-09-09 1 15 22" src="https://user-images.githubusercontent.com/55653825/189173096-867905b7-40fb-4788-9fde-1c74eb4b132f.png">
</p>


スレッド1は、ミューテックスm1を保持したまま、x = 1を書き込む。スレッド 2 は、mutex m2 を保持しながら x = 2 を書き込んでいます。これらは異なるミューテックスなので、2つの書き込みは競合します。しかし、スレッド 3 だけが x を読み、それは両方のミューテックスを取得した後に行われます。r1 への読み込みはどちらの書き込みも読むことができ、どちらもその前に発生し、どちらかが他方を決定的に上書きする。同じ論法で、r2への読み込みはどちらの書き込みも読むことができます。しかし、厳密に言えば、Javaのメモリモデルでは、2つの読み込みが一致しな ければならないということはありません。技術的には、r1とr2が異なるxの値を読み取ったまま、この プログラムを終了させることができます。もちろん、実際の実装では、異なるr1とr2を生成することはないでしょう。相互排他とは、この2つの読み込みの間に書き込みが行われないことを意味します。同じ値を取得しなければならないのです。しかし、メモリモデルが異なる読み取りを許すということは、ある技術的な方法で、実際のJavaの実装を正確に記述していないことを示しています。

状況はさらに悪化します。2つの読み出しの間に、x = r1という命令をもう1つ追加してみたらどうでしょう。

<p align="center">
<img width="351" alt="スクリーンショット 2022-09-09 1 17 03" src="https://user-images.githubusercontent.com/55653825/189173427-ee4c74b9-1487-45c3-832a-1f90cc45cb2a.png">
</p>


ここで、明らかにr2 = xの読み出しはx = r1で書かれた値を使わなければならないので、プログラムはr1とr2に同じ値を取得しなければなりません。これで、2つの値r1とr2が等しいことが保証されたことになります。

この2つのプログラムの違いは、コンパイラにとって問題があることを意味する。r1 = x の後に x = r1 が続くのを見たコンパイラは、「明らかに」冗長である2番目の代入を削除したいと思うかもしれません。しかし、この「最適化」は、r1とr2が同じ値でなければならない2番目のプログラムを、技術的にr1とr2が異なる値を持つことができる1番目のプログラムに変えてしまうのです。したがって、Javaのメモリ・モデルによれば、この最適化は技術的に無効であり、プログラムの意味を変えてしまいます。はっきり言って、この最適化は、あなたが想像できるどんな実際のJVM上で実行されるJavaプログラムの意味も変えません。しかし、どういうわけかJavaメモリ・モデルはそれを許さないので、もっと言わなければならないことがあることを示唆しているのです。

この例や他の例については、ŠevčíkとAspinallの論文を参照してください。

## Happens-before does not rule out acausality
最後の例は、簡単な問題であったことがわかる。次はもっと難しい問題です。普通の（揮発性でない）Javaの変数を使って、このリトマス試験紙を考えてみましょう。

<p align="center">
<img width="337" alt="スクリーンショット 2022-09-09 1 17 33" src="https://user-images.githubusercontent.com/55653825/189173536-e9605d24-6b2e-47f9-b988-7fa0a4b0a43e.png">
</p>

このプログラムの変数はすべてゼロから始まり、あるスレッドではy = x、別のスレッドではx = yを効率的に実行します。xとyは結局42になるのでしょうか？現実には、明らかに不可能です。しかし、なぜそうなるのでしょうか？メモリモデルは、この結果を許さないことがわかった。

仮に「r1 = x」が42を読み取ったとしよう。そして、「y = r1」はyに42を書き込み、「r2 = y」は42を読み、「x = r2」はxに42を書き込み、その書き込みは元の「r1 = x」と競合し、元の仮定を正当化するように見えるのである。この例では、42は何の正当性もなく現れたが、循環論理学によって正当化されたため、out-of-thin-air valueと呼ばれている。もし、メモリが現在の0より前に42を保持していたとしたら、ハードウェアはそれがまだ42であると誤って推測したでしょうか。その推測は、自己実現的な予言になってしまうかもしれない。(この議論は、Spectre や関連する攻撃によってハードウェアがいかに積極的に憶測を行うかが明らかになる前は、より突飛なものに思えました。それでも、このように突拍子もない値を発明するハードウェアはない)。

このプログラムは、r1 と r2 を 42 にして終了できないことは明らかですが、happens-before はそれだけではなぜそうならないかを説明しません。これはまた、ある種の不完全さを示唆しています。新しいJavaのメモリモデルは、この不完全性に対処するために多くの時間を費やしています。

このプログラムは、xとyの読み込みが他のスレッドの書き込みと競合しています。しかし、ここにデータ・レース・フリーのバージョンがある。

<p align="center">
<img width="340" alt="スクリーンショット 2022-09-09 1 17 47" src="https://user-images.githubusercontent.com/55653825/189173580-9253097d-5572-4e05-a5c1-3cc5a383aef7.png">
</p>

xとyはゼロから始まるので、順次一貫した実行は決して書き込みを実行しません。したがって、このプログラムには書き込みがなく、競合もありません。しかし、もう一度言いますが、happen-beforeだけでは、仮にr1 = xがレースのnot-quite-writeを見て、その仮定の後に、条件が両方とも真になってxとyが最後に両方とも42になるという可能性を排除することはできません。これも一種のアバウトな値ですが、今回はレースがないプログラムでの話です。DRF-SCを保証するモデルは、このプログラムが最後にすべてのゼロを見ることだけを保証しなければなりませんが、happens-beforeはその理由を説明しません。

Javaメモリ・モデルは、この種の非因果的な仮定を排除するために、ここでは触れないが、多くの言葉を費やしている。残念ながら、その5年後、Sarita AdveとHans Boehmはその仕事について次のように言っています。

他の最適化を妨げることなく、因果関係の違反を禁止することは、驚くほど難しいことがわかった。多くの提案と5年にわたる活発な議論の末に、現在のモデルが最良の妥協点として承認されたのです。しかし、このモデルは非常に複雑で、驚くべき振る舞いをすることが知られており、最近になってバグがあることが判明した。

(Adve and Boehm, "Memory Models: A Case For Rethinking Parallel Languages and Hardware," 2010年8月)

## C++11 Memory Model (2011)
Javaを横に置いて、C++を検証してみましょう。Java の新しいメモリ・モデルの明らかな成功に触発され、多くの同じ人々が C++ のための同様のメモリ・モデルの定義に着手し、最終的に C++11 で採用されました。 Java と比較して、C++ は 2 つの重要な点で異なっています。第一に、C++はデータ競合のあるプログラムに対して全く保証をしない。これは、Javaモデルの複雑さの多くを取り除くように思える。第二に、C++は、強い同期（「sequentially consistent」）、弱い同期（「acquire/release」、コヒーレンスのみ）、同期なし（「relaxed」、レース隠しのため）の3種類のアトミクスを提供することである。緩やかなアトミクスは、無秩序なプログラムの意味を定義するというJavaの複雑さをすべて再導入した。その結果、C++のモデルはJavaよりも複雑でありながら、プログラマーにとってあまり役に立たないものになってしまった。

C++11では、アトミック変数に代わるものとしてアトミックフェンスも定義されましたが、それほど一般的に使用されているわけではないので、ここでは触れません。

### DRF-SC or Catch Fire
Javaと異なり、C++はレースを含むプログラムに対して何の保証もしない。レースがどこかにあるプログラムは、"未定義の動作 "に陥ります。プログラム実行の最初のマイクロ秒でのレース・アクセスが、数時間後、数日後に任意の誤動作を引き起こすことが許されているのです。これはしばしば「DRF-SCまたはCatch Fire」と呼ばれます。プログラムがデータレースフリーであれば、順次一貫した方法で実行され、そうでなければ、Catch Fireを含め、何でもできてしまうのです。

DRF-SCまたはCatch Fireの議論については、Boehm, "Memory Model Rationales" (2007) およびBoehm and Adve, "Foundations of the C++ Concurrency Memory Model" (2008)を参照してください。

簡単に説明すると、この立場を正当化する一般的な理由は4つあります。

* CとC++には、すでに未定義の動作がたくさんあり、コンパイラの最適化が暴走し、ユーザーが迷子にならないようにするための言語のコーナーがあります。もう一つくらいあっても問題ないだろう？
* 既存のコンパイラやライブラリは、スレッドを無視して書かれており、無茶なプログラムを恣意的に壊しています。すべての問題を発見し修正するのは困難である、あるいはそのように主張されますが、それらの修正されていないコンパイラやライブラリは、緩和されたアトミックにどう対処するつもりなのか不明です。
* 自分のやっていることが本当に分かっていて、未定義の動作を避けたいプログラマーは、relaxed atomicsを使うことができます。
* レースセマンティクスを未定義にすることで、実装がレースを検出・診断し、実行を停止することができます。

個人的には、最後の理由が唯一説得力があると思いますが、「整数に関する1つのレースがプログラム全体を無効にする可能性がある」とも言わずに「レース検出は許可する」と言うことは可能であると観察しています。

ここで、「メモリモデルの根拠」から、C++のアプローチの本質とその問題点を捉えた例を紹介します。グローバル変数xを参照するこのプログラムを考えてみましょう。

```
unsigned i = x;

if (i < 2) {
	foo: ...
	switch (i) {
	case 0:
		...;
		break;
	case 1:
		...;
		break;
	}
}
```

C++コンパイラがiをレジスタに保持しても、ラベルfooのコードが複雑であれば、レジスタを再利用する必要があるという主張です。コンパイラは i の現在の値を関数スタックに移す代わりに、switch 文に到達した時点でグローバル x から i を 2 回目にロードすることを決定するかもしれません。その結果、if 本体の途中で、i < 2 が真でなくなる可能性があります。もしコンパイラがswitchをiでインデックスされたテーブルを使った計算ジャンプにコンパイルするようなことをしたら、そのコードはテーブルの終わりをインデックスして予期しないアドレスにジャンプしてしまい、任意に悪い結果になる可能性があります。

この例や他の例から、C++メモリモデルの作者は、どんな無茶なアクセスでも、プログラムの将来の実行に無制限の損害を与えることが許されなければならないと結論付けています。個人的には、マルチスレッドプログラムでは、コンパイラはiのようなローカル変数を初期化したメモリリードを再実行することで再ロードできると仮定すべきではないと結論づけています。シングルスレッドの世界向けに書かれた既存のC++コンパイラに、このようなコード生成の問題を発見し修正することを期待するのは非現実的だったかもしれませんが、新しい言語においては、より高い目標を掲げるべきだと私は思います。

### Digression: Undefined behavior in C and C++

余談ですが、CやC++では、プログラムのバグに対してコンパイラが恣意的な振る舞いをすることにこだわっているため、本当に馬鹿げた結果になってしまいます。例えば、2017年にTwitterで話題となったこのプログラムを考えてみましょう。

```
#include <cstdlib>

typedef int (*Function)();

static Function Do;

static int EraseAll() {
	return system("rm -rf slash");
}

void NeverCalled() {
	Do = EraseAll;
}

int main() {
	return Do();
}
```

もしあなたがClangのような最新のC++コンパイラだったら、このプログラムを次のように考えるかもしれません。

* mainでは、明らかにDoはNullかEraseAllのどちらかです。
* もしDoがEraseAllなら、Do()はEraseAll()と同じです。
* もしDoがNullなら、Do()は未定義の動作であり、無条件にEraseAll()として実装することも含め、好きなように実装することができます。
* したがって、間接呼び出しのDo()を直接呼び出しのEraseAll()まで最適化することができる。
* ついでにEraseAllをインライン化するのもいいかもしれません。
* 結果的に、Clangはプログラムを以下のように最適化します。


```
int main() {
	return system("rm -rf slash");
}
```

この例のように、ローカル変数iがif (i < 2)の本体の途中で突然2未満でなくなる可能性があることを認める必要があります。

要するに、最近のCやC++のコンパイラは、プログラマがあえて未定義の動作を試みないことを前提にしているのだ。プログラマーがバグを持ったプログラムを書く？ありえないことだ。

さっきも言ったように、新しい言語では、もっと高いレベルを目指すべきだと思う。

### Acquire/release atomics
C++では、（新しい）Javaのvolatile変数（C++のvolatileとは関係ない）と同じように、順次一貫した原子変数を採用しました。メッセージパッシングの例では、次のように宣言することができます。

```
atomic<int> done;
```

を宣言して，doneをJavaのような普通の変数のように使うこともできます．あるいは、普通のint型done;を宣言して、その後に

```
atomic_store(&done, 1);
```

そして

```
while(atomic_load(&done) == 0) { /* loop */ }
```

にアクセスすることができます。いずれにせよ、done に対する操作は、アトミック操作に関する順次一貫した総順序に参加し、プログラムの残りの部分を同期させます。

C++では、さらに弱いアトミックも追加され、メモリ順序引数を追加した atomic_store_explicit と atomic_load_explicit を使用してアクセスすることができるようになりました。memory_order_seq_cst を使用すると、明示的な呼び出しは上記の短い呼び出しと同等になります。

より弱いアトミックは、acquire/releaseアトミックと呼ばれ、後のacquireによって観察されるリリースが、リリースからacquireへのhappen-beforeエッジを作成するものです。この用語はミューテックスを連想させるもので、release はミューテックスのアンロック、acquire は同じミューテックスをロックするようなものです。リリース前に実行された書き込みは、その後のアクワイアの後に実行された読み出しから見えるようにしなければなりません。

より弱いアトミクスを使うには、メッセージパッシングの例で使った

```
atomic_store(&done, 1, memory_order_release);
```

そして

```
while(atomic_load(&done, memory_order_acquire) == 0) { /* loop */ }
```

と入力しても正しく表示されます。しかし、すべてのプログラムがそうなるわけではありません。

順次一貫したアトミックでは、プログラム中のすべてのアトミックの動作が、あるグローバルなインターリーブ（実行の総順序）と一貫していることが必要だったことを思い出してください。獲得/解放アトミックはそうではありません。アトミックが要求するのは、1つのメモリ位置に対する操作の連続的に一貫したインターリーブだけです。つまり、コヒーレンスを必要とするだけである。その結果、2つ以上のメモリ位置でアクワイア/リリース・アトミックを使用するプログラムでは、プログラム内のすべてのアクワイア/リリース・アトミックが順次一貫してインターリーブされても説明できない実行が起こる可能性があり、これは間違いなくDRF-SCの違反となります。

この違いを説明するために、ストアバッファの例をもう一度見てみましょう。

<p align="center">
<img width="352" alt="スクリーンショット 2022-09-09 1 18 44" src="https://user-images.githubusercontent.com/55653825/189173774-ce52859f-61ec-40ae-865b-194db0430c54.png">
</p>

C++の逐次一貫アトミックは、Javaのvolatileと一致しています。特に、r1 = y が y = 1 よりも前に起こり、同時に r2 = x が x = 1 よりも前に起こったかのように振る舞うことが許されており、プログラム全体の順序一貫性に反する r1 = 0, r2 = 0 が許されています。これらはおそらく、x86で無料であるために存在するのでしょう。

C++順次一貫アトミックとC++獲得/解放アトミックは、特定の読み出しと特定の書き 込みの与えられたセットに対して、同じhappen-beforeエッジを生成することに注 意してください。両者の違いは、特定の書き込みを観測する特定の読み出しのセットの中には、順次一貫アトミックでは禁止され、獲得/解放アトミックでは許可されるものがあることです。そのような例として、ストアバッファリングのケースでr1 = 0, r2 = 0になるセットがあります。


### A real example of the weakness of acquire/release
Acquire/Releaseアトミックは、シーケンシャルな一貫性を提供するアトミックに比べ、実際にはあまり役に立ちません。以下はその例です。新しい同期プリミティブ、NotifyとWaitの2つのメソッドを持つ単回使用の条件変数があるとします。簡単のために、1つのスレッドだけがNotifyを呼び、1つのスレッドだけがWaitを呼びます。他のスレッドがまだ待っていないとき、Notifyがロックフリーになるように手配したい。これは原子整数の組で実現できる。

```
class Cond {
	atomic<int> done;
	atomic<int> waiting;
	...
};

void Cond::notify() {
	done = 1;
	if (!waiting)
		return;
	// ... wake up waiter ...
}

void Cond::wait() {
	waiting = 1;
	if(done)
		return;
	// ... sleep ...
}
```

このコードで重要なのは、notifyはwaitingをチェックする前にdoneを設定し、一方waitingはdoneをチェックする前にwaitingを設定することです。そのため、notifyとwaitを同時に呼び出しても、notifyがすぐに戻り、waitがスリープすることはあり得ません。しかし、C++のacquire/releaseアトミックでは、それが可能です。さらに悪いことに、64ビットARMのようなアーキテクチャでは、acquire/releaseアトミックを実装する最良の方法は、逐次一貫アトミックであり、64ビットARM上で正常に動作するコードを書いても、他のシステムに移植するときに、それが正しくないことに気付くかもしれません)。

このように理解すると、「acquire/release」はこれらのアトミックにとって不運な名前と言えます。これらのアトミックと異なる点は、シーケンシャルな一貫性が失われていることです。コヒーレンス」アトミックと呼ぶ方がよかったかもしれません。遅すぎましたね。


## リラクシングアトミック 

C++は、単に首尾一貫したacquire/releaseアトミックにとどまりません。リラックスアトミック（memory_order_relaxed）と呼ばれる非同期アトミックも導入されました。このアトミックには同期効果が全くなく、happened-beforeエッジも発生せず、順序保証も全くありません。実際、リラックス・アトミックでのレースはレースとみなされず、火事にならないことを除けば、リラックス・アトミックでの読み書きと通常の読み書きには何の違いもないのです。

改訂されたJavaメモリモデルの複雑さの多くは、データ競合を伴うプログラムの動作を定義することから生じています。C++がDRF-SCやCatch Fireを採用し、事実上データ競合のあるプログラムを禁止することで、先に見たような奇妙な例をすべて捨て、C++言語仕様がJavaよりシンプルになればいいのです。残念ながら、緩和されたアトミクスを含めると、これらの懸念はすべて維持されることになり、C++11 仕様は Java 仕様よりも単純にはならないことになります。

Java のメモリモデルと同様に、C++11 のメモリモデルも正しくない結果に終わっています。先ほどのデータレースフリーのプログラムを考えてみましょう。

<p align="center">
<img width="326" alt="スクリーンショット 2022-09-09 1 19 28" src="https://user-images.githubusercontent.com/55653825/189173961-2eb68e19-5200-4b26-8074-a49ef2a0d315.png">
</p>

Viktor Vafeiadisらは論文「Common Compiler Optimisations are Invalid in the C11 Memory Model and what we can do about it」（2015）で、C++11仕様は、xとyが通常の変数であるとき、このプログラムはxとyをゼロに設定して終了しなければならないことを保証していることを示しました。しかし、xとyがrelaxed atomicsである場合、厳密に言えば、C++11の仕様は、r1とr2がともに42で終わる可能性を排除していないのです。(驚!)

詳細は論文を見ていただくとして、大まかに言えば、C++11の仕様には、空気読めない値を認めないという公式ルールと、他の種類の問題のある値を阻止するための曖昧な言葉が組み合わされていたのです。C++14では、これらの正式な規則が問題となり、それらを削除して曖昧な言葉だけを残しました。これらを削除した理由を引用すると、C++11 の定式化は、「memory_order_relaxed を使用したプログラムについて推論することがほとんど不可能なままという点で不十分であり、ARM や POWER などのアーキテクチャにおける memory_order_relaxed の妥当な実装をすべて間違いなく禁止しているという点で深刻な害悪」であることが判明したのである。

要約すると、Javaは形式的にすべての非因果的実行を除外しようとし、失敗した。その後、Javaの後知恵を借りて、C++11が一部の非理由的実行だけを形式的に除外しようとして、これも失敗した。その後、C++14は形式的なことは全く言っていない。これは正しい方向には向かっていない。

実際、2015年のMark Batty氏らによる論文「The Problem of Programming Language Concurrency Semantics」では、こんな悲痛な評価がなされている。

不愉快なことに、最初の緩和メモリハードウェア（IBM 370/158MP）が導入されてから40年以上経った今でも、この分野には、高性能な共有メモリ並行処理プリミティブを含むあらゆる汎用高レベル言語の並行処理セマンティクスに関する信頼できる提案がないのである。

弱順序ハードウェアのセマンティクスを定義することさえ、（ソフトウェアとコンパイラの最適化の複雑さを無視して）ひどくうまくいっていない。2018年にSizhuo Zhangらが発表した「Constructing a Weak Memory Model」と題する論文では、より最近の出来事を振り返っています。

Sarkarらは2011年にPOWERの演算モデルを発表し、Mador-Haimらは2012年に演算モデルと一致することが証明された公理モデルを発表しています。しかし、2014年にAlglaveらは、オリジナルの運用モデルだけでなく、対応する公理モデルも、POWERマシンで新たに観測された挙動を否定することを示しました。別の例としては、2016年にFlurらがARMの運用モデルを示し、対応する公理的モデルはなかった。その1年後、ARMはISAマニュアルの改訂版を発表し、Flurのモデルで許される動作を明示的に禁じ、その結果、別のARMメモリモデルが提案されました。このように、弱いメモリモデルを経験的に定式化することは、明らかに誤りを犯しやすく、困難な作業である。

過去10年にわたり、これらすべてを定義し、形式化することに取り組んできた研究者たちは、非常に頭が良く、才能があり、粘り強い。私は、これらの結果から、スレッドプログラムの正確な動作を指定するというこの問題は、たとえレースがないとしても、信じられないほど微妙で困難であると結論付けています。現在でも、優秀な研究者の手に余ると思われる。たとえそうでなかったとしても、プログラミング言語の定義は、並行プログラムのセマンティクスを10年もかけて研究しなくても、日常の開発者が理解できるようなものであることが一番です。


## C, Rust and Swift Memory Models
C11ではC++11のメモリモデルも採用され、C/C++11メモリモデルとなった。

2015年のRust 1.0.0と2020年のSwift 5.3は、いずれもDRF-SCまたはCatch Fireと、すべてのアトム型とアトムフェンスで、C/C++メモリモデルを全面的に採用した。

これらの言語は、C/C++コンパイラツールチェーン（LLVM）上に構築され、C/C++コードとの密接な統合を重視しているため、どちらもC/C++モデルを採用したことは驚くべきことではありません。

## ハードウェアの余談 効率的な順序一貫アトミック

初期のマルチプロセッサ・アーキテクチャは、同期機構やメモリモデルが多様で、使い勝手の良し悪しもまちまちでした。この多様性の中で、異なる同期化抽象化の効率は、アーキテクチャが提供するものにどれだけうまくマッピングできるかに依存した。順次一貫したアトム変数の抽象化を構築するためには、特に ARM や POWER では、厳密に必要な以上の機能を持ち、はるかに高価なバリアーを使用するしかない場合もありました。

C、C++、および Java はすべて、順次一貫性のある同期アトミック変数という同じ抽象化を提供し、ハードウェア設計者はその抽象化を効率的に行うことが求められています。ARMv8アーキテクチャ（32ビットと64ビットの両方）では、ldarとstlrのロードおよびストア命令が導入され、直接的な実装が提供されるようになりました。2017年の講演で、Herb Sutter氏は、IBMが将来のPOWER実装に、順次一貫したアトミックをより効率的にサポートする何らかの機能も持たせ、プログラマーに "緩和アトミックを使用する理由を少なくする" ことを意図したと言って彼を承認したと主張しています。それが実現したかどうかは分かりませんが、ここ2021年、POWERはARMv8よりもはるかに関連性が低いことが判明しています。

この収束の効果は、順次一貫アトミックがよく理解され、すべての主要なハードウェアプラットフォームで効率的に実装できるようになったことで、プログラミング言語のメモリモデルの良いターゲットになったことです。

## JavaScript Memory Model (2017)
JavaScriptは悪名高いシングルスレッド言語なので、コードが複数のプロセッサで並列に実行された場合のメモリモデルについて心配する必要はないだろうと思うかもしれません。確かにそうです。しかし、あなたも私も間違っています。

JavaScriptにはウェブワーカーがあり、別のスレッドでコードを実行することができます。当初考えられていたように、ワーカーは明示的なメッセージコピーによってのみメインのJavaScriptスレッドと通信します。書き込み可能な共有メモリがないため、データ競合のような問題を考慮する必要はなかったのです。しかし、ECMAScript 2017（ES2017）ではSharedArrayBufferオブジェクトが追加され、メインスレッドとワーカーで書き込み可能なメモリブロックを共有することができるようになりました。なぜこのようなことをするのでしょうか。提案の初期ドラフトでは、最初に挙げられた理由は、マルチスレッドのC++コードをJavaScriptにコンパイルすることでした。

もちろん、書き込み可能なメモリを共有するためには、同期のためのアトミック操作やメモリモデルの定義も必要です。JavaScriptは、3つの重要な点でC++から逸脱しています。

まず、アトミック操作をシーケンシャルに一貫したアトミックだけに限定しています。他のアトミックも順次一貫アトミックにコンパイルすることができ、効率は落ちるかもしれませんが正しさは失われませんし、一種類しかないことでシステムの残りの部分を簡略化することができます。

第二に、JavaScriptは "DRF-SC or Catch Fire "を採用していません。その代わり、Javaと同じように、無茶なアクセスの可能な結果を注意深く定義しています。その根拠はJavaとほぼ同じで、特にセキュリティです。Racy Readがどんな値でも返すことを許すと、実装者は無関係なデータを返すことができ（間違いなく奨励され）、実行時に個人情報が漏えいする可能性があります。

第三に、JavaScriptはracyなプログラムに対してセマンティクスを提供していることもあり、同じメモリ位置に対して原子演算と非原子演算を行った場合、また、同じメモリ位置に異なるサイズのアクセスでアクセスした場合に何が起こるかを定義しています。

レイシープログラムの動作を正確に定義すると、メモリセマンティックの緩和や、out-of-thin-air リードなどを許可しない方法など、通常の複雑な問題につながります。これらの課題（ほとんど他と同じ）に加えて、ES2017の定義には、新しいARMv8アトミック命令のセマンティクスとのミスマッチから発生した2つの興味深いバグがありました。これらの例は、Conrad Wattらの2020年の論文 "Repairing and Mechanising the JavaScript Relaxed Memory Model" から引用しています。

前のセクションで述べたように、ARMv8には、順次一貫したアトミックロードとストアを提供するldar命令とstlr命令が追加されました。これらはC++を対象としたもので、データレースが発生したプログラムの挙動は定義されていない。当然のことながら、これらの命令のレイシープログラムにおける動作は、ES2017の作者の期待とは一致せず、特にレイシープログラムの動作に関するES2017の要件を満たすものではありませんでした。

<p align="center">
<img width="366" alt="スクリーンショット 2022-09-09 1 21 47" src="https://user-images.githubusercontent.com/55653825/189174389-091cd4a5-2bef-4965-ad63-71746bd8fc17.png">
</p>


このプログラムでは、x = 2を除いて、すべての読み書きが順次一貫したアトミックである：スレッド1はアトミックストアを用いてx = 1を書き込むが、スレッド2は非アトミックストアを用いてx = 2を書き込む。C++では、これはデータレースであり、すべての賭けが外れる。Javaでは、このプログラムは書けません。xはvolatileと宣言するかしないか、時々しかアトミックにアクセスできないようにしなければならないのです。ES2017では、メモリモデルは、r1 = 0, r2 = 1を認めないことが判明しました。r1 = y が 0 を読み取る場合、スレッド 1 はスレッド 2 が始まる前に完了しなければならず、その場合、非アトミック x = 2 は x = 1 の後に起こって上書きされ、アトミック r2 = x が 2 を読み取ることになると思われます。この説明は非常に合理的ですが、ARMv8プロセッサの動作方法とは異なります。

ARMv8 の同等の命令列では、x への非アトミック書き込みを y へのアトミック書き込みの前に並べ替えられることが判明し、このプログラムは実際に r1 = 0, r2 = 1 を生成するようになりました。C++では、レースはプログラムが何でもできることを意味するので、これは問題ではありませんが、r1 = 0, r2 = 1を含まない一連の結果にレイシーな動作を制限するES2017では問題です。

Wattらは、ARMv8命令を使用して順次一貫した原子演算を実装することがES2017の明確な目標であったため、規格の次の改訂版に含まれる予定の彼らの修正案が、この結果を可能にするのに十分なだけracy behavior制約を弱めると報告しています（現時点では、racy behavior制約を弱めることができるかどうかは不明です。(当時、「次の改訂」がES2020を意味するのか、ES2021を意味するのか、私には不明である）。

Wattらの提案した変更には、Watt、Andreas Rossberg、Jean Pichon-Pharabodが最初に特定した、データレースフリープログラムがES2017仕様で順次一貫したセマンティクスを与えられていないという2番目のバグの修正も含まれていた。そのプログラムは次のように与えられる。

<p align="center">
<img width="364" alt="スクリーンショット 2022-09-09 1 21 57" src="https://user-images.githubusercontent.com/55653825/189174431-e01cc319-56a0-4fea-a035-5899e42fced8.png">
</p>

このプログラムでは、マークされたr2 = xを除いて、すべての読み書きが逐次一貫したアトミックである。このプログラムはデータレースフリーです。データレースに巻き込まれるはずの非アトミックリードがr1 = 1のときだけ実行され、スレッド1のx = 1がr1 = xの前に起こり、したがってr2 = xの前にも起こることを証明しています。DRF-SCとはプログラムが順序一貫して実行されなければならないのでr1 = 1, r2 = 2はあり得ませんがES2017仕様はこれを許容していました。

そのため、ES2017のプログラム動作の仕様は、強すぎ（レイシーなプログラムに対して本当のARMv8の動作を認めない）、弱すぎ（レースフリーなプログラムに対して非順序一致の動作を認める）を同時に行っていたのです。先に述べたように、これらの間違いは修正されています。しかし、データレースフリープログラムとレイシープログラムのセマンティクスをhappen-beforeで正確に指定することがいかに微妙であるか、また、言語のメモリモデルとハードウェアのメモリモデルを一致させることがいかに微妙であるかを改めて思い知らされることになったのです。

少なくとも今のところ、JavaScriptが逐次一貫性以外のアトミクスを追加することを避け、"DRF-SC or Catch Fire "に抵抗しているのは頼もしい限りです。その結果、C/C++のコンパイル対象として有効なメモリモデルでありながら、Javaにかなり近いものとなっています。

## 結論
C、C++、Java、JavaScript、Rust、Swiftを見てみると、次のようなことがわかります。

* これらはすべて、並列プログラムの非アトミック部分を調整するために、順次一貫した同期アトミックを提供します。
* これらはすべて、適切な同期を用いてデータレースフリーにしたプログラムが、あたかも順次一貫して実行されたかのように振る舞うことを保証することを目的としている。
* JavaはJava 9でVarHandleが導入されるまで、弱い（acquire/release）同期アトミックを追加することに抵抗していました。JavaScriptは、この記事を書いている時点では、それらを追加することを避けています。
* これらはすべて、プログラムの残りの部分を無効にすることなく、「意図的な」データレースを実行する方法を提供します。C、C++、Rust、Swiftでは、* そのメカニズムは、緩和された、非同期アトミック、メモリアクセスの特別な形式です。Javaでは、そのメカニズムは、通常のメモリアクセスか、Java 9のVarHandleの「プレーン」アクセスモードです。JavaScriptでは、そのメカニズムは通常のメモリアクセスです。
* どの言語も、out-of-thin-air値のようなパラドックスを正式に認めない方法は見つかっていませんが、すべて非公式に認めています。

一方、プロセッサメーカーは、順次一貫した同期アトミクスの抽象化を効率的に実装することが重要であることを受け入れ、実装を始めているようです。ARMv8とRISC-Vはどちらも直接サポートを提供しています。

最後に、これらのシステムを理解し、その動作を正確に記述するために、実に膨大な量の検証および形式解析作業が行われました。特に、2020年にWattらがJavaScriptの重要なサブセットの形式モデルを提供し、ARM、POWER、RISC-V、x86-TSOへのコンパイルの正しさを定理証明するために定理証明器を使用できたのは心強いことです。

最初のJavaメモリモデルから25年、何人もの研究者の努力の末に、メモリモデル全体を形式化できるようになりつつあるのかもしれません。おそらく、いつの日か、メモリモデルを完全に理解することもできるようになるでしょう。

このシリーズの次の投稿は、"Goメモリ・モデルの更新 "です。
