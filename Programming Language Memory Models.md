# [日本語訳] プログラミング言語のメモリモデル -Programming Language Memory Models-
> *Original Article*: https://research.swtch.com/plmm
> 
> This article is translated by [@mox692](https://twitter.com/mox692). Please contact me if any problem.

プログラミング言語のメモリモデルは、並列プログラムがスレッド間でメモリを共有するために、どのような動作に依存できるかという問題に答えるものである。例えば，x と done がゼロから始まる C 言語によるプログラムを考えてみよう．

<img width="423" alt="スクリーンショット 2022-09-07 19 15 09" src="https://user-images.githubusercontent.com/55653825/188853749-bce53231-0e73-49b6-b7ab-99061119ca4f.png">

このプログラムは，メッセージの受信準備が整ったことを示す信号として done を使い，x のメッセージをスレッド 1 からスレッド 2 に送ろうとするものである．スレッド1とスレッド2がそれぞれ専用のプロセッサで実行され、両方が完了するまで実行された場合、このプログラムは意図したとおりに終了し、1を印刷することが保証されているのだろうか？このような疑問に答えるのが、プログラミング言語のメモリモデルである。

プログラミング言語によって詳細は異なりますが、C、C++、Go、Java、JavaScript、Rust、Swiftなど、基本的に現代のすべてのマルチスレッド言語について、いくつかの一般的な回答が当てはまります。

* まず、x と done が普通の変数である場合、スレッド 2 のループは決して止まらない可能性があります。一般的なコンパイラの最適化は、変数の最初の使用時にレジスタにロードし、その後、その変数への将来のアクセスのために、できるだけ長くそのレジスタを再利用することです。もしスレッド2がdoneをスレッド1の実行前にレジスタにコピーすると、スレッド1が後でdoneを変更したことに気づかず、ループ全体にわたってそのレジスタを使い続けるかもしれません。
* 第二に、たとえスレッド 2 のループが停止しても、done == 1 を観察して、x が 0 であると表示するかもしれません。コンパイラはしばしば、最適化のヒューリスティックや、コード生成中にハッシュテーブルや他の中間データ構造をトラバースする方法に基づいてプログラムの読み取りと書き込みの順序を変更します。スレッド 1 用のコンパイルされたコードは x を done の前ではなく後に書き込んでしまうかもしれませんし、スレッド 2 用のコンパイルされたコードは x をループの前に読み込んでしまうかもしれません。

このプログラムがいかに壊れているかを考えると、どのように修正するかが明らかな問題です。

最近の言語では、アトミック変数やアトミック操作という形で、プログラムがスレッドを同期させるための特別な機能が提供されています。doneをアトム変数にすれば（アトム操作を採用している言語ではアトム操作で）、プログラムの終了とprint1が保証される。doneをアトミックにすると、いろいろな効果があります。

* スレッド 1 のコンパイルされたコードは、done への書き込みが可視になる前に x への書き込みが完了し、他のスレッドから可視であることを確認する必要があります。
* スレッド 2 用のコンパイル済みコードはループの各反復で done を (再) 読み込まなければなりません。
* スレッド 2 用のコンパイル済みコードは、done からの読み込みの後に x から読み込まなければなりません。
* コンパイルされたコードは、これらの問題のいずれかを再導入する可能性のあるハードウェア最適化を無効にするために必要なことは何でもしなければなりません。

元のプログラムでは、コンパイラがコードを並べ替えた後、スレッド1がxを書き、同時にスレッド2がそれを読むことができました。これはデータレースである。修正後のプログラムでは、アトム変数doneがxへのアクセスを同期させる役割を果たし、スレッド1がxを書き込んでいるときにスレッド2がそれを読むことは不可能になった。このプログラムでは、データレースが発生しない。一般に、現代の言語では、データレースフリーのプログラムは、あたかも異なるスレッドの操作を任意に、しかし順序を変えずに単一のプロセッサにインターリーブしたように、常に逐次一貫した方法で実行されることが保証されている。余談だが、このアトミック変数やアトミック演算は「シンクロナイジング・アトミック」と呼ぶのが適切であろう。確かにデータベース的にはアトミックな操作であり、同時に読み書きを行っても、ある順番で順次実行されているかのように振る舞う。しかし、アトミックがプログラムの他の部分を同期させ、アトミックでないデータ上の競合を排除する方法を提供することはさらに重要です。標準的な用語は「アトミック」なので、この記事でもそれを使っています。プログラミング言語のメモリモデルは、プログラマとコンパイラの間の契約として、何が必要かを詳細に規定するものです。プログラミング言語のメモリモデルは、プログラマとコンパイラの間で交わされる契約書のようなものである。現在でも、2次的な質問については、言語間で大きな違いがある。

* アトム変数自体の順序保証は？
* ある変数にアトミック操作と非アトミック操作の両方がアクセスできますか？
* アトミック以外の同期機構はありますか？
* 同期をとらないアトミック演算はありますか？
* 競合があるプログラムは全く保証されないのですか？ 

この記事では、いくつかの前置きをした後、さまざまな言語がこれらの問題や関連する問題にどのように答えているか、またそこに到達するまでにどのような経路をたどってきたかを調べます。また、この投稿では、何が有効で何が有効でないかをまだ非常によく学んでいることを強調するために、その過程で多くの失敗があったことを強調しています。

## Hardware, Litmus Tests, Happens Before, and DRF-SC

特定の言語の詳細に触れる前に、ハードウェアのメモリモデルから得た教訓を簡単にまとめておきます。アーキテクチャが異なると、命令を並べ替えられる量が異なるため、複数のプロセッサで並列に実行するコードは、アーキテクチャによって異なる結果が得られる可能性があります。この場合、異なるプロセッサで実行されるプログラムは、あたかも1つのプロセッサにある順番でインターリーブされたかのように振る舞わなければなりません。このモデルは、開発者が推論するのがはるかに簡単ですが、保証を弱めることで性能が向上するため、現在では重要なアーキテクチャが提供していません。異なるメモリモデルを比較して完全に一般的な発言をするのは困難です。異なるメモリモデルを比較して完全に一般的な発言をすることは困難です。その代わりに、リトマス試験と呼ばれる特定のテストケースに焦点を当てることが有効です。あるリトマス試験で2つのメモリモデルが異なる動作をした場合、それは両者が異なることを証明し、少なくともその試験ケースについて、一方が他方より弱いか強いかを確認するのに役立つのが一般的です。例えば、先に調べたプログラムのリトマス試験形式は次のとおりです。

<img width="582" alt="スクリーンショット 2022-09-07 19 25 46" src="https://user-images.githubusercontent.com/55653825/188856136-67aac9c3-4cc3-4bb4-b8e4-9941eb0a648c.png">


前の投稿と同様に、すべての例はすべての共有変数にゼロが設定されて始まるものとしています。rNという名前は、レジスタや関数ローカル変数のようなプライベートなストレージを表し、xやyのような他の名前は、個別の共有（グローバル）変数を表します。実行終了時にレジスタの特定の設定が可能かどうかを問う。r1 = 1, r2 = 0という結果は、元のプログラムのスレッド2がループを終了し（doneはy）、その後0を表示することに対応します。アセンブリ言語版では、0を表示することはx86では不可能ですが、ARMやPOWERのようなより緩やかなアーキテクチャでは、プロセッサ自体の順序変更最適化により可能です。最近の言語では、コンパイル時に並べ替えを行うことができるため、ハードウェアがどうであれ、このような結果を得ることができます。先に述べたように、現在のプロセッサは、順次一貫性を保証する代わりに、「データレースフリー順次一貫性」またはDRF-SC（SC-DRFとも書くことがあります）と呼ばれる特性を保証します。DRF-SCを保証するシステムには、同期命令と呼ばれる、異なるプロセッサ（スレッド）を連携させるための特定の命令を定義する必要がある。例えば、あるプログラムを2つのスレッドで短時間実行した場合の図を示します。

<img width="587" alt="スクリーンショット 2022-09-07 19 27 58" src="https://user-images.githubusercontent.com/55653825/188856431-da0275d6-58f4-4539-b92b-88d0c8160231.png">


このプログラムも前回の記事で見ました。スレッド1とスレッド2が同期命令S(a)を実行します。このプログラムの特定の実行では、2つのS(a)命令はスレッド1からスレッド2へのhappen-before関係を確立するので、スレッド1のW(x)はスレッド2のR(x)の前に起こる。happen-beforeによって順番付けされていない異なるプロセッサ上の二つのイベントは、同じ瞬間に発生するかもしれない：正確な順番は不明である。正確な順序は不明である。我々はこれらを同時実行と呼ぶ。データレースとは、ある変数への書き込みが、その同じ変数の読み出しまたは別の書き込みと同時に実行されることです。DRF-SCを提供するプロセッサは（最近ではすべてのプロセッサが）、データレースのないプログラムは、あたかも順次一貫したアーキテクチャで実行されているかのように動作することを保証している。DRF-SCは、先に見たように、現代言語が高水準言語で正しいマルチスレッドプログラムを書くために採用した基本的な保証でもあるのです。

## Compilers and Optimizations
コンパイラが最終的な実行コードを生成する過程で、入力プログラムの演算を並べ替え る可能性があることを何度か述べました。一般に、コンパイラは通常のメモリへの読み書きをほぼ任意に並べ替えることができると考えられていますが、並べ替えによってコードのシングルスレッド実行が変化しないことが条件です。例えば、次のようなプログラムを考えてみましょう。

<img width="149" alt="スクリーンショット 2022-09-07 19 29 56" src="https://user-images.githubusercontent.com/55653825/188856768-25d95b79-5212-41c7-970d-30f136e5dc6e.png">

x、y、zはすべて異なる変数なので、この4つの文はコンパイラが最適と考える任意の順序で実行することが可能です。ハードウェアの記事では、ARM/POWERアーキテクチャが保証するものの例として、コヒーレンスについて見てきました：

<img width="595" alt="スクリーンショット 2022-09-07 19 30 39" src="https://user-images.githubusercontent.com/55653825/188856920-0fdb16ae-1b4c-4b79-b6bc-424ecdb2e2b3.png">


最近のハードウェアはすべてコヒーレンスを保証しており、これは単一のメモリ位置に対する操作の順序的整合性と見なすこともできます。このプログラムでは、どちらかの書き込みがもう一方を上書きしなければならず、システム全体がどちらがどちらかについて合意しなければならない。しかし、コンパイル時にプログラムの順序を入れ替えるため、現代の言語ではコヒーレンスを提供することすらできないことが判明した。 例えば、コンパイラがスレッド4で2つの読み出し命令を並べ替えたとすると、

<img width="484" alt="スクリーンショット 2022-09-07 19 36 30" src="https://user-images.githubusercontent.com/55653825/188857945-0115be20-fd2b-49db-baf0-7270ef872b42.png">

結果、r1 = 1、r2 = 2、r3 = 2、r4 = 1となるが、これらは、組立プログラムでは不可能だったが高級言語で可能だったのだ。このように、プログラミング言語のメモリモデルは、最も緩やかなハードウェアのメモリモデルよりも弱いものばかりです。しかし、いくつかの保証はあります。DRF-SCは、シングルスレッド・コードでは有効であった最適化であっても、新たな読み取りや書き込みを発生させる最適化を認めないものである。例えば、次のコードを考えてみよう： 

```
if(c) {
	x++;
} else {
	... lots of code ...
}
```

elseに多くのコードがあり、if本文にはx++しかないif文がある。分岐を少なくして、if本体を完全になくす方が安上がりかもしれない。if の前に x++ を実行し、間違っていたら大きな else 本体の x-- で調整すればいいのです。つまり、コンパイラはそのコードを次のように書き換えることを考えるかもしれない：

```
x++;
if(!c) {
	x--;
	... lots of code ...
}
```

これは安全なコンパイラの最適化なのだろうか？シングルスレッド・プログラムでは、イエスです。この例は、Hans Boehmが2004年に発表した論文「Threads Cannot Be Implemented As a Library」の中の一説に由来しており、言語はマルチスレッド実行のセマンティクスについて黙ってはいられないと主張している。プログラミング言語のメモリモデルは、どの最適化が許され、どの最適化が許されないかという質問に正確に答える試みである。プログラミング言語のメモリモデルは、どのような最適化が許され、どのような最適化が許されないかという問題に正確に答えようとする試みです。過去数十年にわたりこのモデルを記述しようとした歴史を調べることで、何がうまくいき、何がうまくいかなかったかを知り、物事がどこへ向かっているのかを知ることができるのです。

## Original Java Memory Model (1996)
Javaは、マルチスレッドプログラムに対して保証する内容を書き出そうとした最初の主流言語です。この言語にはミューテックスが含まれ、それが意味するメモリ順序の要件が定義されています。また、「揮発性」アトミック変数も含めました。揮発性変数のすべての読み込みと書き込みは、メインメモリで直接プログラム順に実行することが求められ、揮発性変数に対する操作が順次一貫した方法で動作するようにしました。最後に、Javaはデータレースがあるプログラムの動作も規定した（あるいは少なくとも規定しようとした）。その1つが、通常の変数に対するコヒーレンスの形式を義務付けることであり、これについては後ほど詳しく検討します。残念ながら、この試みはJava言語仕様の初版（1996年）において、少なくとも2つの重大な欠陥があった。これらは、後知恵で、すでに述べた前置きを使えば簡単に説明できます。当時は、それほど明白ではありませんでした。


### Atomics need to synchronize
第一の欠点は、揮発性の原子変数が非同期であるため、プログラムの他の部分の競合を排除するのに役立たないことです。上で見たメッセージパッシングプログラムのJava版は次のようになります。

<img width="362" alt="スクリーンショット 2022-09-07 19 49 23" src="https://user-images.githubusercontent.com/55653825/188860502-ce37ca82-2d62-4262-a674-3b6888d28102.png">

doneはvolatileと宣言されているので、ループの終了が保証されます。コンパイラはdoneをレジスタにキャッシュして無限ループを引き起こすことはできません。しかし、プログラムが1を表示することは保証されていない。コンパイラはxとdoneへのアクセスを並べ替えることを禁止していませんし、ハードウェアが同じことをするのを禁止する必要もありません。Javaのvolatileは非同期のアトミックなので、それを使って新しい同期プリミティブを構築することはできません。その意味で、オリジナルのJavaのメモリモデルは弱すぎたのです。

### Coherence is incompatible with compiler optimizations
スレッドがメモリ位置の新しい値を読み取ると、古い値を読み取るように見えることはない、というコヒーレンスを強制することで、コンパイラの基本的な最適化を阻害していました。先に、読み込みの順番を変更するとコヒーレンシが失われることを説明しましたが、「読み込みの順番を変更しなければいい」と思うかもしれません。ここでは、別の最適化、すなわち共通部分式の削除によってコヒーレンシが失われる可能性のある、より微妙な方法を説明します。
次のようなJavaプログラムを考えてみましょう。

<img width="356" alt="スクリーンショット 2022-09-07 19 51 45" src="https://user-images.githubusercontent.com/55653825/188860950-119ea769-74a0-41ca-a0e4-729a9bc90c86.png">

しかし、もしpとqが同じオブジェクトを指していて、iとjの読み込みの間に別のスレッドがp.xに書き込んだとしたら、kに古い値iを再利用するとコヒーレンスに違反することになります。冗長な読み出しを最適化できないため、ほとんどのコンパイラーは、生成されるコードが遅くなります。ハードウェアは動的最適化を適用できるため、コヒーレンスを提供することはコンパイラーよりも簡単です。これに対し、コンパイラは静的な最適化しか行えないため、どのようなアドレスや値が使われても正しい命令列をあらかじめ書いておかなければならない。この例では、コンパイラは、pとqがたまたま同じオブジェクトを指しているかどうかによって、何が起こるかを簡単に変えることができない。少なくとも、両方の可能性に対応するコードを書き出さない限り、時間と空間のオーバーヘッドが大きくなる。コンパイラは、メモリ位置間のエイリアシングの可能性について不完全な知識を持っているため、実際にコヒーレンスを提供するには、基本的な最適化をあきらめなければなりません。Bill Pugh氏は、1999年の論文 "Fixing the Java Memory Model" でこの問題やその他の問題を指摘しています。

## New Java Memory Model (2004)
このような問題があり、またオリジナルのJava Memory Modelは専門家でも理解するのが難しかったため、Pugh氏らはJavaの新しいメモリモデルを定義する取り組みを開始した。そのモデルはJSR-133となり、2004年にリリースされたJava 5.0に採用された。標準的な参考文献は、Jeremy Manson、Bill Pugh、Sarita Adveによる「The Java Memory Model」（2005年）、およびMansonの博士論文に詳細が記載されています。新しいモデルは、DRF-SCアプローチに従っています。データレースフリーのJavaプログラムは、逐次一貫した方法で実行されることが保証されている。

### Synchronizing atomics and other operations
あるスレッドがアトミックでない変数を書き込むとき、他のスレッドがそれを読み書きしているときに同時に書き込まないようにするために、プログラマはhappened-beforeエッジを確立する同期操作を必要とします。Javaでは、主な同期操作は以下の通りです。

* スレッドの生成は、そのスレッドでの最初の動作の前に行われる。
* mutex mのロック解除は、その後にmをロックするよりも前に行われる。
* volatile変数vへの書き込みは、それに続くvの読み出しの前に行われる。
  
subsequent "とはどういう意味ですか？Javaでは、すべてのロック、アンロック、揮発性変数へのアクセスは、あたかも順次一貫したインターリーブで発生したかのように振る舞い、プログラム全体におけるこれらの操作の合計順を与える、と定義しています。「後続 "とは、その総順序の中で後になることを意味します。つまり、ロック、アンロック、揮発性変数へのアクセスの総順序がsubsequentの意味を定義し、次にsubsequentが特定の実行によってどのhappens-before edgeが作られるかを定義し、そしてhappens-before edgeがその特定の実行にデータレースがあるかどうかを定義します。レースがない場合、その実行は順次一貫した方法で動作する。

揮発性アクセスは、ある総順序で行動しなければならないということは、ストアバッファのリトマス試験において、r1 = 0とr2 = 0で終わってはいけないということです。

<img width="329" alt="スクリーンショット 2022-09-07 19 56 17" src="https://user-images.githubusercontent.com/55653825/188861802-e1f9013a-9d9f-4b38-8b67-d50e51a6e152.png">

Javaでは、揮発性変数xとyに対して、読み込みと書き込みの順序を変えることはできません。1つの書き込みは2番目に来る必要があり、2番目の書き込みに続く読み込みは最初の書き込みを見なければなりません。ここで重要な、しかし微妙なポイントがあります。それは、すべての同期操作の合計順序は、happens-beforeの関係とは別であるということです。プログラム中のすべてのロック、アンロック、揮発性変数へのアクセスの間に、一方向にhappens-beforeのエッジが存在するわけではありません。例えば、異なるミューテックスのロックとアンロック、異なる変数の揮発性アクセスは、これらの操作が集合的にあたかも1つの順次一貫したインターリーブに従って動作しなければならないにもかかわらず、それらの間にhappens-beforeエッジを持たない。

### Semantics for racy programs


## Happens-before does not rule out acausality
最後の例は、簡単な問題であったことがわかる。では、もっと難しい問題です。普通の(揮発性でない)Java変数を使って、次のリトマス試験を考えてみましょう：リトマス試験。Racy Out Of Thin Air ValuesCan this program see r1 = 42, r2 = 42?// Thread 1 // Thread 2r1 = x r2 = yy = r1 x = r2（明らかに違う！）このプログラムのすべての変数はいつものようにゼロから始まり、このプログラムはあるスレッドでy = x、他のスレッドでx = yを効率的に実行します。xとyは結局42になるのでしょうか？現実には、明らかに無理だ。しかし、なぜそうなるのでしょうか？仮に、"r1 = x "が42を読み取ったとしよう。そして、「y = r1」がyに42を書き込み、「r2 = y」が42を読んで、「x = r2」がxに42を書き込み、その書き込みが元の「r1 = x」と競合し、元の仮定を正当化するように見えるのである。この例では、42は何の正当性もなく現れたが、循環論理学によって正当化されたため、out-of-thin-air valueと呼ばれている。もし、メモリが現在の0より前に42を保持していたとしたら、ハードウェアはそれがまだ42であると誤って推測したでしょうか。その推測は、自己実現的な予言になってしまうかもしれない。(この議論は、Spectre や関連する攻撃によってハードウェアがどれだけ積極的に推測しているかが明らかになる前は、より突飛なものに思えました。このプログラムは、r1とr2が42のままでは終われないことは明らかですが、happens-beforeだけでは、なぜそうならないかの説明にはなりません。これはまた、ある種の不完全さを示唆しています。このプログラムにはレースがあります。xとyの読み込みが、他のスレッドの書き込みとレースしているのです。しかし、ここにデータ・レース・フリーのバージョンがあります。Litmus Test: Non-Racy Out Of Thin Air ValuesCan this program see r1 = 42, r2 = 42?// Thread 1 // Thread 2r1 = x r2 = yif (r1 == 42) if (r2 == 42)y = r1 x = r2（明らかに違う！）xとyはゼロから始まるので、どんな順列一貫実行でも書き込みを決して実行しないので、このプログラムには書き込みがなく、レースも存在しないのです。しかし、もう一度言いますが、happen-beforeだけでは、仮にr1 = xがレースのnot-quite-writeを見て、その仮定の後に、条件が両方とも真になり、xとyが最後に両方とも42になるという可能性を排除することはできません。これも一種のアバウトな値ですが、今回はレースがないプログラムでの話です。DRF-SCを保証するモデルは、このプログラムが最後にすべてのゼロを見ることだけを保証しなければなりませんが、happens-beforeはその理由を説明しません。Javaのメモリモデルは、この種の因果関係のない仮説を排除しようと、ここでは触れない多くの単語を費やしています。残念ながら、5年後、Sarita AdveとHans Boehmはこの仕事について次のように言っています：他の望ましい最適化を禁止しない方法で、このような因果関係の違反を禁止することは、驚くほど難しいことが判明しました。多くの提案と5年にわたる活発な議論の末に、現在のモデルが最良の妥協点として承認されました。...残念ながら、このモデルは非常に複雑で、驚くべき振る舞いをすることが知られており、最近になってバグがあることが明らかになった(Adve and Boehm, "Memory Models: A Case For Rethinking Parallel Languages and Hardware," 2010年8月)

## C++11 Memory Model (2011)


## 結論
C、C++、Java、JavaScript、Rust、Swiftを見ると、次のような見解が得られます：これらはすべて、並列プログラムの非アトミック部分を調整するための順序一貫した同期アトミックを提供しています。これらはすべて、プログラムの残りの部分を無効にすることなく「意図的な」データレースを実行する方法を提供するものです。C、C++、Rust、Swiftでは、そのメカニズムは、緩和された非同期アトミックで、メモリアクセスの特別な形式です。Javaでは、そのメカニズムは、通常のメモリアクセスか、Java 9のVarHandleの「プレーン」アクセスモードです。一方、プロセッサメーカーは、順次一貫した同期アトミックを抽象化して効率的に実装することが重要であることを認め、実装を始めているようです。最後に、これらのシステムを理解し、その動作を正確に記述するために、実に膨大な量の検証および形式解析作業が行われました。特に、2020年にWattらがJavaScriptの重要なサブセットの形式モデルを与え、定理証明器を用いてARM、POWER、RISC-V、x86-TSOへのコンパイルの正しさを証明できたことは励みになります。最初のJavaメモリモデルから25年、何人世紀もの研究努力を経て、我々はメモリモデル全体を形式化できるようになり始めているかも知れません。このシリーズの次の投稿は、「Goメモリモデルの更新」です。
