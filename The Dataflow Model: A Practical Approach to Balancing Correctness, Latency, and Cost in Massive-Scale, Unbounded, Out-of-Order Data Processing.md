# [日本語訳] Dataflow: スケーラブルでUnboundedでアウトオブオーダーなデータ処理における、正確性、レイテンシ、コストの最適化へのアプローチ -The Dataflow Model: A Practical Approach to Balancing Correctness, Latency, and Cost in Massive-Scale, Unbounded, Out-of-Order Data Processing-
> *Original Article*: https://storage.googleapis.com/pub-tools-public-publication-data/pdf/43864.pdf
> 
> This article is translated by [@mox692](https://twitter.com/mox692). Please contact me if any problem.

## Abstract
Webログ、モバイル利用統計、センサーネットワークなど、日々のビジネスにおいて、無制限、非順序、グローバルスケールのデータセットがますます一般的になってきています。  
同時に、これらのデータセットの消費者は、より速い答えへの飽くなき欲求に加えて、データ自体の特徴によるイベント時間順序やウィンドウのような高度な要件を発展させてきました。一方、実用性を考えると、このようなタイプの入力に対して、正確性、レイテンシ、コストのすべての次元で完全に最適化することはできません。その結果、データ処理の専門家は、これらの一見相反する命題の間の緊張関係をどのように調整するかという難問に直面することになり、しばしばバラバラの実装やシステムになってしまいます。私たちは、現代のデータ処理におけるこれらの進化した要件に対処するためには、アプローチの根本的な転換が必要であると提案しています。  
この問題を解決する唯一の方法は、原理的な抽象化を介して、実務家が関心のある軸（正確さ、待ち時間、コスト）に沿って適切なトレードオフを選択できるようにすることである。 この論文では、そのようなアプローチの1つであるDataflowModel1について、それが可能にするセマンティクスの詳細な検証、その設計を導いた基本原則の概要、およびその開発につながった実世界の経験によるモデル自体の検証を交えて紹介します。

## 1: Introduction
MapReduce [16]とその後継（Hadoop [4]，Pig [18]，Hive [29]，Spark [33]など）が可能にしたスケールから，SQLコミュニティにおけるストリーミングに関する膨大な作業（例． クエリシステム[1, 14, 15]、ウィンドウウィング[22]、データストリーム[24]、タイムドメイン[28]、セマンティックモデル[9]）、最近の低遅延処理であるSpark Streaming[34], MillWheel, Storm[5], など、現代のデータ消費者は大規模障害をより大きな価値を持つ組織構造に整形し手懐けることに多大な力を発揮しているのです。  
しかし，既存のモデルやシステムは，多くの一般的なユースケースでまだ不足しています．最初の例として，ストリーミングビデオプロバイダが，ビデオ広告を表示してコンテンツを収益化し，視聴した広告の量を広告主に請求したいと考えています．このプラットフォームは、コンテンツと広告のオンラインとオフラインのビューをサポートしています。ビデオプロバイダは、ビデオと広告に関する統計情報を集約するだけでなく、毎日各広告主に請求する金額を知りたいと考えています。広告主やコンテンツプロバイダーは、自分たちの動画がどのくらいの頻度で、どのくらいの時間、どのコンテンツ/広告で、どの人口統計グループによって視聴されているかを知りたいと考えています。彼らはalsowantは、彼らが充電/支払われているどのくらい知っている。Theytheyが予算や入札を調整し、ターゲティングを変更し、tweakcampaigns、およびできるだけリアルタイムに近い将来の方向性を計画できるように、できるだけ早くこの情報のすべてをtheywant。  
データ処理システムはもともと複雑ですが、ビデオプロバイダーはシンプルで柔軟性のあるプログラミングモデルを求めています。このようなユースケースで計算しなければならない情報は、基本的に各ビデオの視聴時間と長さ、誰がそれを見たか、どの広告やコンテンツとペアになっているか（つまりユーザーごと、ビデオ視聴セッションごと）である。概念的には簡単なことですが、既存のモデルやシステムは、いずれもこの要件を満たすには不十分です。  
このようなユースケースで計算しなければならない情報は、基本的に各ビデオ視聴の時間と長さ、誰がそれを見たか、どの広告またはコンテンツとペアリングされたか（つまり、ユーザーごと、ビデオ視聴セッションごと）であります。MapReduce（およびPigやHiveを含むHadoopの亜種）、FlumeJava、Sparkなどのバッチシステムは、すべての入力データをバッチに集めてから処理する際に特有のレイテンシーの問題に悩まされています。また、多くのストリーミングシステムでは、スケーラブルなフォールトトレラントをどのように維持するかが不明です（Aurora [1]、 TelegraphCQ [14]、 Niagara [15]、 Esper[17] ）。  
スケーラビリティとフォールトトレランスを提供するものは、表現力や正しさのベクトルで不足がある。多くは、正確な一度きりというセマンティクスを提供する能力を欠き（Storm, Samza[7], Pulsar[26] ）、正しさに影響を及ぼしています。また、ウィンドウ処理に必要な時間プリミティブがない(Tigon[11])、あるいはウィンドウ処理のセマンティクスがアップルまたは処理時間ベースのウィンドウに限定されている(Spark Streaming[34], Sonora[32], Trident[5])．  
イベントタイムベースのウィンドウを提供するものは、順序付けに依存するか(SQLStream [27])、イベントタイムモードでのウィンドウトリガーセマンティクスが限定されています(Stratosphere/Flink [3, 6])。CEDR [8]とTrill [13]は、パンクチュエーションによる有用なトリガーセマンティクス [30, 28]を提供するだけでなく、ここで提案するものと非常に類似した全体的な漸進モデルを提供するという点で注目に値する。  
しかし、それらのウィンドウセマンティクスはセッションを表現するには十分でなく、それらの周期的なパンクチュアリ はセクション3.3のいくつかの使用ケースには十分ではありません。MillWheelとSpark Streamingはともに十分にスケーラブルで、フォールトトレラントで、低レイテンシーであり、妥当な基板として機能しますが、イベントタイムセッションを簡単に計算できる高レベルのプログラミングモデルがありません。  
Lambda Architecture [25]システムは、望ましい要件の多くを達成することができますが、2つのシステムを構築し、維持しなければならないため、単純性という軸では失敗しています。Summingbird [10]は、バッチ処理とストリーミング処理を一つのインターフェースに集約することで、実装の複雑さを改善していますが、そのために実行できる計算の種類に制限があり、運用の複雑さが2倍になります。  

しかし、上記のすべてのモデルとシステム（CEDRとTrillは例外）の主要な欠点は、入力データ（無制限かそれ以外か）を、ある時点で完全なものにすることに焦点を当てていることだと考えています。このアプローチは、今日の膨大かつ高度に無秩序なデータセットの現実と、消費者が求めるセマンティクスやタイムリーさが衝突したときに、根本的な欠陥になると考えています。また、現在存在するような多様で多様なユースケース（将来的に発生する可能性のあるものは言うまでもない）に対して広く実用的な価値を持つようなアプローチは、特定のユースケースに適した正確さ、遅延、コストのバランスを取るためのシンプルかつ強力なツールを提供しなければならないと考えています。  
最後に、私たちは、実行エンジンがシステムのセマンティクスを決定するという一般的な考え方を超える時が来たと考えています。適切に設計、構築されたバッチ、マイクロバッチ、ストリーミングシステムは、すべて同じレベルの正確性を提供でき、この3つはすべて、今日、無限のデータ処理に広く使用されています。十分な一般性と柔軟性を持つモデルの下に抽象化された実行エンジンの選択は、レイテンシとリソースコストという、実行エンジン間の実用的な根本的な違いにのみ基づくものになり得ると、私たちは考えています。

そのような観点から、本論文の概念的な成果として、次の単一の統一されたモデルを挙げる:

* データ自体の特徴によってウィンドウ化されたイベント時順序付き結果の計算が可能。データ自体の特徴によってウィンドウ化されたイベント時順序付き結果の計算を、無限の順序付きデータソースに対して行うことができます。
* パイプラインの実装を4つの関連する次元で分解し、明確性、複合性、柔軟性を提供します。
  * What: どのような結果が計算されるのか
  * Where: イベント時間のどこで計算されるか
  * When: 処理時間内の、いつ結果が具体化されるか
  * How: 以前の結果が後の改良とどのように関連するか
* データ処理の論理的な概念と、その基礎となる物理的な実装を分離する。物理的な実装と分離し、バッチ処理、マイクロバッチ処理 バッチ、マイクロバッチ、ストリーミングエンジンの選択が、単に正確さ、遅延 バッチ、マイクロバッチ、ストリーミングエンジンの選択は、単に正確さ、レイテンシ、コストの問題になります。

具体的には、以下のような貢献が可能になります。
* イベントタイムの非整列ウィンドウをサポートするウィンドウモデル、およびその作成と利用のためのシンプルなAPI（2.2項）
*  結果の出力時間をパイプラインの実行時特性に結びつけるトリガーモデルで、希望するトリガーセマンティクスを記述するための強力で柔軟な宣言型APIを備えています（セクション2.3）
* 前述（2.3節）のウィンドウウィングとトリガーモデルに、リトラクトとアップデートを統合したインクリメンタルな処理モデルです。
* MillWheelストリーミングエンジンとFlumeJavaバッチエンジンの上に、ランタイムに依存しないオープンソースのSDK [19]を含むGoogle Cloud Dataflow用の外部再実装で、上記のスケーラブルな実装を行いました（セクション3.1）
* このモデルの設計の指針となった一連の基本原則（セクション3.2）
* このモデルの開発の動機となった、Google社における大規模、無制限、無秩序なデータ処理に関する実体験を簡単に説明する（セクション3.3）

最後に、このモデルには何の不思議もないことを指摘しておきます。既存の強一貫バッチ、マイクロバッチ、ストリーミング、ラムダアーキテクチャの各システムでは計算不可能なことも、CPU、RAM、ディスクの固有の制約があるため、そのまま適用されます。その一方で、手元のデータやリソースの実態を考慮し、特定の問題領域に対してレイテンシや正しさを正確に調整する能力も提供します。その意味で、実用的な大規模データ処理パイプラインの構築のしやすさを目指したモデルである。


## 1.1: Unbounded/Bounded vs Streaming/Batch
無限／有限のデータセットを表現する場合、我々はストリーミング／バッチよりも、unbounded／boundedという用語を好む。現実には、非有界データセットは、その概念からバッチシステムの反復実行を使用して処理されており、よく設計されたストリーミングシステムは有界データを処理することが完全に可能である。モデルの観点から、ストリーミングまたはバッチの区別はほとんど無意味であり、したがって、この用語は実行時実行エンジンを記述するためだけに確保する。

## 1.2: ウィンドウ
ウィンドウ処理 [22] は、データセットを有限のチャンクに分割し、グループとして処理するものです。非束縛データを扱う場合、ウィンドウ処理は一部の処理（集約、外部結合、時間制限のある処理など、ほとんどのグループ化において有限の境界を定義するため）には必要ですが、他の処理（フィルタリング、マッピング、内部結合など）には必要ありません。境界のあるデータでは、ウィンドウ処理は基本的に任意ですが、多くの状況で意味的に有用な概念です（例えば、以前に計算された境界のないデータソースの一部に対する大規模な更新の埋め戻しなど）。  
多くのシステムがタプルベースのウィンドウをサポートしていますが、これは本質的に論理的な時間領域における時間ベースのウィンドウであり、順番に増加する論理的なタイムスタンプを持つ要素です。ウィンドウは、アライメントされた、つまり問題の時間ウィンドウの全データに適用される場合と、アライメントされていない、つまり与えられた時間ウィンドウのデータの特定のサブセット（例えば、キーごと）にのみ適用される場合がある。  
固定ウィンドウ（タンブリングウィンドウと呼ばれることもある）は、1時間ごとのウィンドウや1日ごとのウィンドウなど、静的なウィンドウサイズで定義される。つまり、すべてのウィンドウは、対応する期間のすべてのデータに適用されます。窓の補完負荷を時間的に均等にするために、各キーの窓をランダムな値で位相シフトすることで、整列させないこともある。  
スライディングウィンドウは、ウィンドウサイズとスライド期間によって定義される。周期はサイズより小さくてもよく、これはウィンドウが重なる可能性があることを意味する。この図はスライドしているように見えますが、5つのウィンドウはウィンドウ3だけでなく、図の中の3つのキーすべてに適用されます。  
セッションは、データのサブセット（この場合はキーごと）の活動のある期間を捕捉するウィンドウである。一般的に、セッションはタイムアウトギャップで定義される。タイムアウトより短い時間内に発生したすべてのイベントは、セッションとしてグループ化される。セッションは非整列ウィンドウである。例えば、ウィンドウ2はキー1のみに、ウィンドウ3はキー2のみに、ウィンドウ1と4はキー3のみに適用される。

<p align="center">
<img width="323" alt="スクリーンショット 2022-07-10 18 14 13" src="https://user-images.githubusercontent.com/55653825/178138683-904b4a2f-5d27-4a59-add3-fc5e943cb7b5.png">  
</p>

## 1.3 Time Domains
時間の中の出来事に関連するデータを処理するとき、考慮すべき2つの固有の時間の領域がある。文献の様々な場所で捕捉されているが（特に時間管理[28]と意味モデル[9]、またウィンドウウィンドウィング[22]、アウトオブオーダー処理[23]、句読点[30]、心拍[21]、ウォーターマーク[2]、フレーム[31]）、セクション2.3の詳しい例は概念を明確に心に留めておいたほうがわかりやすいだろう。興味のある2つの領域は以下の通りである。

* イベント時間：イベント自体が実際に発生した時間であり、発生時のシステムクロックの記録である。
*  処理時間：パイプライン内の処理中の任意の時点でイベントが観測された時間、つまり、システムクロックによる現在時刻。分散システム内のクロック同期については仮定していないことに注意。

処理中は、使用されているシステムの現実（通信遅延、スケジューリングアルゴリズム、処理時間、パイプラインのシリアル化など）により、2つの領域間のスキューが固有かつ動的に変化することになります。パンクチュエーションやウォーターマークなどのグローバルな進捗状況メトリクスは、このスキューを視覚化する良い方法を提供します。これは、パイプラインによって処理されたイベント時間の下限値（しばしばヒューリスティックに確立される）です。  
上述したように、完全性の概念は一般に正しさと相容れないので、ウォーターマークをそのようなものとして信頼することはありません。しかし、ウォーターマークは、イベント時刻のある時点までのすべてのデータが観測された可能性が高いとシステムが考えるときの有用な概念を提供します。  
したがって、スキューを視覚化するだけでなく、システム全体の健全性と進捗状況を監視したり、基本的なガベージコレクションポリシーのように完全な正確さを必要としない進捗状況の判断を行う場合にも応用できます。理想的には、時間領域のスキューは常にゼロであり、すべてのイベントが発生するとすぐに処理することが必要でした。しかし、現実はそう甘くはなく、図2のような状態になることが多い。12:00頃から、パイプラインの遅れによってウォーターマークが実時間から離れ始め、12:02頃には実時間に近づき、12:03頃になると再び大きく遅れています。  
このような動的な歪みは、分散データ処理システムでは非常に一般的であり、正しい再現性のある結果を提供するために必要な機能を定義する上で大きな役割を果たすことになる。

<p align="center">
<img width="232" alt="スクリーンショット 2022-07-10 18 20 34" src="https://user-images.githubusercontent.com/55653825/178138886-5291ff33-4ece-4b0a-afec-3a6c5897ea07.png">
</p>


## 2: Dataflow Model
このセクションでは、システムの正式なモデルを定義し、そのセマンティクスが標準的なバッチ、マイクロバッチ、ストリーミングモデル、およびラムダアーキテクチャのハイブリッドストリーミングとバッチセマンティクスを包含できるほど汎用的である理由を説明します。コード例としては、FlumeJava APIを発展させたDataflow Java SDKの簡略版を使用する予定です。

## 2.1 Core Primitives
まず始めに、古典的なバッチモデルからのプリミティブを考えてみましょう。データフローSDKには、システムを流れる（キー、値）ペアを操作する2つのコア変換があります。

* ParDoによる汎用並列処理。処理対象となる各入力要素（それ自体は有限のコレクションでもよい）は、ユーザー定義関数（データフローではDoFnと呼ばれる）に提供され、入力ごとに0個以上の出力要素を得ることができる。例えば、入力されたキーの接頭辞をすべて展開し、それらの間で値を複製する処理を考えてみよう。  
<p align="center">
<img width="315" alt="スクリーンショット 2022-07-10 18 30 05" src="https://user-images.githubusercontent.com/55653825/178139138-1e314081-a050-4da5-8e4c-3c28408f82f2.png">
</p>

* GroupByKey for key-grouping (key, value) pairs.

一方、GroupByKey演算は、与えられたキーに対応するすべてのデータを収集し、下流に送って削減します。入力ソースが非限定である場合、いつ終了するかを知る方法がない。この問題に対する一般的な解決策は、データをウィンドウ化することである。

<p align="center">
<img width="432" alt="スクリーンショット 2022-07-10 18 31 02" src="https://user-images.githubusercontent.com/55653825/178139156-fe6b1441-61c9-43d9-93af-b67b832858ff.png">
</p>

## 2.2: Windowing
グループ化をサポートするシステムは、通常、GroupByKey操作を再定義して、本質的にGroupByKeyAndWindowとします。ここでの我々の主な貢献は、非整列ウィンドウのサポートで、これには2つの重要な洞察がある。1つ目は、モデルの観点からは、すべてのウィンドウ戦略を非整列として扱い、基礎となる実装が整列されたケースに関連する最適化を適用できるようにすることがより簡単であることです。もうひとつは、ウィンドウを2つの関連する操作に分離できることである。
- Set<Window> AssignWindows(T datum)は、0個以上のウィンドウに要素を割り当てる。これは、本質的にLi [22]のバケット演算子である。
- Set<Window> MergeWindows(Set<Window> windows) は，グループ化時にウィンドウをマージする．これは、データ駆動型ウィンドウが、データが到着しグループ化されるにつれて、時間と共に構築されることを可能にする。任意のウィンドウ戦略について、2つの操作は密接に関連している：スライドウィンドウの割り当てにはスライドウィンドウのマージ、セッションウィンドウの割り当てにはセッションウィンドウのマージ、などが必要。要素はイベント時間のタイムスタンプでシステムに提供され (これはパイプラインの任意の時点で変更することもできる8)、イベント時間のすべてをカバーするデフォルトのグローバルウィンドウに最初に割り当てられ、標準バッチモデルのデフォルトと一致するセマンティクスを提供します。

<p align="center">
<img width="264" alt="スクリーンショット 2022-07-10 18 34 07" src="https://user-images.githubusercontent.com/55653825/178139258-34369ae4-2a51-4768-af35-382244e814ab.png">
</p>

## 2.2.1 Window Assignment
モデルの観点からは、ウィンドウの割り当てにより、割り当てられた各ウィンドウに要素の新しいコピーが作成されます。たとえば、図3に示すように、幅2分、周期1分のスライドウィンドウでデータセットをウィンドウ化することを考えてみましょう（簡潔にするため、タイムスタンプはHH:MM形式で示されます）。この場合、2つの（キー、値）ペアはそれぞれ、要素のタイムスタンプと重なる両方のウィンドウに存在するように複製されます。ウィンドウは、それが属する要素と直接関連付けられるので、これは、ウィンドウの割り当てが、グループ化が適用される前のパイプラインのどこでも発生する可能性があることを意味します。これは、グループ化操作が合成変換（Sum.integerPerKey() など）の下流のどこかに埋もれてしまう可能性があるため、重要なポイントになります。

## 2.2.2 Window Merging
ウィンドウのマージはGroupByKeyAndWindow操作の一部として行われ、サンプルのコンテキストで説明するのが最も良い。ここでは、セッションウィンドウを使用することにする。図4は4つのデータ（k1が3つ、k2が1つ）の例で、セッションごとにウィンドウ化され、30分のセッションタイムアウトがあることを示している。すべてのデータはシステムによってデフォルトのグローバルウィンドウに配置される。AssignWindowsのセッション実装は、各要素をそれ自身のタイムスタンプから30分延長した単一のウィンドウに入れる。このウィンドウは、それ以降のイベントが同じセッションの一部とみなされる場合に入ることのできる時間の範囲を示す。次に、GroupByKeyAndWindow操作を開始します。これは、実際には5つの部分からなる複合操作です: 

* DropTimestapmps: 要素のタイムスタンプを削除、今後はウィンドウのみが関連するため
* GroupByKey: Groups (value, window) tuples by key.
* Merge Windows: あるキーに対して現在バッファされているウィンドウをマージします。実際のマージロジックは、ウィンドウ戦略によって定義される。この場合、v1とv4のウィンドウは重なっているので、セッションウィンドウ戦略では、太字で示すように、それらを1つの新しい大きなセッションにマージする。
* GroupAlsoByWindow: 各キーについて、ウィンドウ単位で値をグループ化する。前のステップでマージした後、v1とv4は同じウィンドウになったので、このステップで一緒にグループ化される。
* ExpandToElements: キーごと、ウィンドウごとの値のグループを、ウィンドウごとの新しいタイムスタンプを持つ（キー、値、イベント時間、ウィンドウ）タプルに展開します。この例では、タイムスタンプをウィンドウの最後に設定していますが、ウィンドウ内の最も古いイベントのタイムスタンプ以上であれば、電子透かしの正確さに関して有効です。


## 2.2.3 API
ウィンドウ処理の簡単な例として、キー付き整数の合計を計算する次の Cloud Dataflow SDK コードを考えてみましょう。
<p align="center">
<img width="372" alt="スクリーンショット 2022-07-10 18 40 32" src="https://user-images.githubusercontent.com/55653825/178139461-4b7de694-a3cf-4aa7-9209-93195e53e8b9.png">
</p>

同じことを、図4のように30分のタイムアウトでセッションをウィンドウ化するには、集計を開始する前にWindow.intoを1回呼び出すことになる。

<p align="center">
<img width="369" alt="スクリーンショット 2022-07-10 18 41 40" src="https://user-images.githubusercontent.com/55653825/178139501-3aafa45d-24a4-4b69-8778-c43830e5f685.png">
</p>


<p align="center">
<img width="287" alt="スクリーンショット 2022-07-10 18 39 28" src="https://user-images.githubusercontent.com/55653825/178139422-d8a282a2-d7b2-4d38-ad96-8470bab7c1e5.png">
</p>

## 2.3 Triggers & Incremental Processing
非整列のイベントタイムウィンドウを構築する能力は進歩ですが、さらに2つの欠点に対処する必要があります。
- タプルと処理時間ベースのウィンドウのサポートを提供する方法が必要で、そうでなければ、現存する他のシステムと比較して、ウィンドウのセマンティクスを後退させることになる。
- あるウィンドウの結果をいつ出力するかを知る方法が必要である。
  
タプルと処理時間ベースのウィンドウの問題は、ウィンドウの完全性の問題に対する解 決策を構築した後、セクション2.4で扱う。ウィンドウの完全性に関しては、透かしのようなある種のグローバルなイベント-時間進捗 メトリックを使用することで解決しようとする考えがある。しかし、電子透かし自体には、正しさの点で2つの大きな欠点がある。
- 電子透かしは速すぎる場合があり、透かしの後ろに到着するデータが遅れる可能性がある。分散したデータソースの場合、完全に完璧なイベントタイムウォーターマークを導き出すことは困難であり、出力データに100%の正確さを求めるのであれば、ウォーターマークだけに頼ることは不可能である。
- 速度が遅い。また、イベントタイムスキューの変動が少ない健全なパイプラインであっても、入力ソースによってはベースラインのスキューが数分以上になることがあります。

これらの理由から、我々は透かしだけでは不十分であると仮定している。完全性の問題に対処する上で有用な洞察は、ラムダアーキテクチャが効果的に問題を横取りすることです。それは、何らかの方法で正しい答えをより速く提供することによって完全性の問題を解決するのではなく、単にストリーミングパイプラインが提供できる結果の最善の低遅延の推定を提供し、バッチパイプラインが実行すれば最終的に一貫性と正確さを約束します10。 この機能はトリガーと呼ばれ、与えられたウィンドウの出力結果をいつトリガーするかを指定することができます。トリガーは、内部または外部からの信号に応答してGroupByKeyとWindowの結果の生成を刺激するメカニズムで、ウィンドウモデルとは相補的なものです。
- ウィンドウは、イベント時間内のどこでデータがグループ化され処理されるかを決定する。
- トリガーは、グループ化の結果が処理時間内にいつペインとして出力されるかを決定します。

我々のシステムは、完了予測（例えば、パーセンタイル透かしを含む透かし。これは、バッチおよびストリーミング実行エンジンにおいて、入力データの最後の一片まで処理するよりも、最小限の割合を迅速に処理することに関心がある場合に、はぐれ者を扱うための有用なセマンティクスを提供する）、処理時間のポイント、データの到着に対する応答（カウント、バイト、データパンチュレーション、パターンマッチなど）でトリガするための事前定義トリガー実装を提供します。また、トリガーを論理組み合わせ（and, or, etc）、ループ、シーケンス、その他の構成にすることも可能です。  
さらに、ユーザは実行ランタイムの基本的なプリミティブ（例：ウォーターマークタイマー、処理時間タイ マー、データ到着、合成サポート）とその他の関連する外部シグナル（データ注入要求、外部プログレス メトリクス、RPC完了コールバックなど）の両方を利用して、独自のトリガーを定義することができます。

- 破棄する。トリガがかかると、ウィンドウの内容は破棄され、後の結果は以前の結果とは無関係になります。このモードは、データの下流消費者（パイプラインの内部または外部）が、さまざまなトリガ発火からの値が独立していることを期待する場合に有用です（例えば、注入された値の合計を生成するシステムに注入する場合）。また、バッファリングされるデータ量の点でも最も効率的ですが、DataflowCombinerとしてモデル化できる連想演算や可換演算では、効率性の差は最小になることが多いようです。ビデオセッションのユースケースでは、下流のデータ消費者に部分的なセッションをつなぎ合わせることを要求するのは非現実的であるため、これは十分ではありません。

- 蓄積型。トリガーされると、ウィンドウのコンテンツは永続的な状態でそのまま残され、後の結果は以前の結果の洗練されたものになる。これは、下流の消費者が同じウィンドウの複数の結果を受け取るときに、古い値を新しい値で上書きすることを期待する場合に便利です。これは、ストリーミングパイプラインが低レイテンシーの結果を生成し、それが将来的にバッチパイプラインからの結果によって上書きされる、Lambdaアーキテクチャシステムで使用されるモードです。ビデオセッションの場合、単にセッションを計算し、更新をサポートする出力ソース（データベースやキー/バリューストアなど）にすぐに書き込むのであれば、これで十分かもしれません。

- Accumulating & Retracting。トリガがかかると、蓄積セマンティクスに加え、送信された値のコピーも永続的な状態に保存される。将来、ウィンドウが再びトリガーされたとき、まず前の値のリトラクトが発行され、その後、通常のデータムとして新しい値が発行される12。複数のGroupByKeyAndWindow操作を連続して行うパイプラインでは、引き戻しが必要である。なぜなら、1つのウィンドウで生成された複数の結果が、その後のトリガーでグループ化される際に別々のキーになる可能性があるからである。この場合、2つ目のグループ化操作は、元の出力の効果を逆転させるべきであるとリトラクトによって通知されない限り、それらのキーに対して誤った結果を生成する。可逆的なデータフローコンバイナー操作は、アンバインメソッドによって効率的にリトラクションをサポートすることができます。ビデオセッションの場合、このモードが理想的である。セッション生成の下流で、セッション自体のプロパティに依存する集約を行う場合、例えば不人気な広告（大多数のセッションで5秒未満しか視聴されていない広告など）を検出する場合、最初の結果は、入力が時間経過とともに進化するため無効になることがあります（例えば、かなりの数のオフラインのモバイル視聴者がオンラインに戻ってセッションデータをアップロードすると、無効になることがあります）。Retractionsは、複数のシリアル・グルーピング・ステージを持つ複雑なパイプラインにおいて、このようなタイプの変化に適応するための方法を提供します。


## 2.4 Examples
ここで、データフローモデルがサポートする複数の有用な出力パターンを強調する一連の例について考えてみることにする。各例は、セクション2.2.3の整数和のパイプラインのコンテキストで見ていきます。

<p align="center">
<img width="334" alt="スクリーンショット 2022-07-10 18 58 28" src="https://user-images.githubusercontent.com/55653825/178140065-2ffd71a9-1e25-4686-a4a0-0e38caa4e7b3.png">
</p>


入力ソースから10個のデータ点を観測していると仮定しよう、それぞれ小さな整数値である。ここでは、有界と無界の両方のデータソースのコンテキストでそれらを検討します。実際のパイプラインでは、ここで説明するような操作は複数のキーに対して並列に行われる。図5は、これらのデータの関係を、時間軸に沿って示したものである。X軸はイベントタイム（実際にイベントが発生した時間）、Y軸は処理タイム（パイプラインがイベントを観測した時間）でデータをプロットしたものである。全ての例は、特に指定がない限り、我々のストリーミングエンジン上で実行されることを想定している。また、多くの例では透かしに依存しており、その場合は透かしも図に含めています。理想的な透かしと実際の透かしの例をグラフにする。傾き1の点線は、理想的な電子透かしを表している。つまり、イベント時間の歪みがなく、すべてのイベントが発生したときにシステムで処理される場合である。図5では、実際の電子透かしが蛇行し、濃い破線で表されているのがその例である。また、この電子透かしのヒューリスティックな性質は、透かしの後ろに表示される値9の1つの「遅れた」データによって示されていることにも注意が必要である。


<p align="center">
<img width="272" alt="スクリーンショット 2022-07-10 18 59 39" src="https://user-images.githubusercontent.com/55653825/178140096-7e7f7f2a-f99e-4ecf-acdf-125f32d11676.png">
</p>

もし、これらのデータを従来のバッチシステムで処理するとしたら、すべてのデータが到着するのを待ち、それらを1つのバンドルにまとめ（これらのデータはすべて同じキーであるため）、それらの値を合計して51という結果を得ることになります。この結果は図6の黒く塗りつぶした長方形で表され、その面積は合計に含まれるイベント時間と処理時間の範囲をカバーしている（長方形の上部は処理時間内のいつ結果が具体化されたかを表す）。古典的なバッチ処理はイベント時間を問わないので、結果はイベント時間をすべてカバーする単一のグローバルウィンドウに含まれる。また、出力はすべての入力を受け取ってから計算されるので、結果は実行の処理時間すべてをカバーします。

<p align="center">
<img width="257" alt="スクリーンショット 2022-07-10 19 00 21" src="https://user-images.githubusercontent.com/55653825/178140117-6a7ca86f-7af2-406d-bd93-76cc503ea2b5.png">
</p>

この図には、ウォーターマークが含まれていることに注意してください。しかし 典型的なバッチ処理では使われないが、ウォーターマークは意味的に 意味的には、すべてのデータが処理されるまで、時間の最初に保持され、その後、無限に進 意味的には、すべてのデータが処理されるまで、時間の最初に保持され、その後、無限大に進められる。ここで重要なのは、従来のバッチ処理と同じセマンティクスを得ることができることである。 ストリーミングシステムでデータを処理することで、古典的なバッチ処理と同じセマンティクスを得ることができる。 このようにウォーターマークが進行するストリーミングシステムでデータを実行することで、古典的なバッチと同じセマンティクスを得ることができる。 さて、このパイプラインを変換して、無限のデータソース上で動作させたいとします。 を実行するように変換したいとします。データフローでは、デフォルトのトリガーセマンティクスとして、ウォーターマークが通過するときにウィンドウを出すようになっている。しかし、グローバルウィンドウを無限の入力ソースで使用する場合 しかし、無限の入力ソースでグローバルウィンドウを使用する場合、そのようなことは決して起こらないことが保証されています。 グローバルウィンドウはイベント時間のすべてをカバーするため、そのようなことは起こらないことが保証されています。そのため そのため、デフォルトのトリガー以外の何かでトリガーをかけるか、あるいは デフォルトのトリガか、グローバルウィンドウ以外のウィンドウで グローバルウィンドウ以外の何かでウィンドウを作る必要があります。さもなければ、何の出力も得られないでしょう。 まず、トリガーを変更することについて見てみましょう。 概念的に同一の出力(すべての時間にわたるグローバルなキーごとの合計)を生成することができます。 しかし、定期的なアップデートで、概念的に同じ出力（すべての時間にわたるグローバルなキーごとの合計）を生成することができます。この例では、Window.triggerオペレーションを適用します。 を適用し、1 分の周期的な処理時間の境界で繰り返し起動します。 を適用しています。また、Accumulatingモードを指定し、グローバル サムが時間の経過とともに洗練されていくようにします。 グローバル サムが時間と共に精緻化されるように、アキュムレーティング モードを指定している。 キーに対する以前の結果を新しい結果で単純に上書きできる出力シンク、たとえばデータベースや キー/バリューストアなど)。したがって、図7では、処理時間1分につき1回、更新された グローバルサムは処理時間1分につき1回更新される。どのように 半透明の出力矩形が重なっていることに注目してください。これは、累積ペインが処理時間の重複領域を取り込むことによって、以前の結果を基に構築されるためです。 これは、蓄積ペインが処理時間の重複する領域を取り込むことによって、以前の結果を基に構築されるためです。

<p align="center">
<img width="334" alt="スクリーンショット 2022-07-10 19 01 40" src="https://user-images.githubusercontent.com/55653825/178140164-a3a0dde3-1442-4d6a-b18b-5a55a75b316e.png">
</p>

もし、1分間に1回、合計でデルタを生成したい場合は、図8のように破棄モードに切り替えることができます。これは、多くのストリーミングシステムで提供されている処理時間ウィンドウのセマンティクスを効果的に提供していることに留意してください。これらの結果は、処理時間の独立した領域からのデータを取り込むため、出力ペインはもはや重なりません。

<p align="center">
<img width="336" alt="スクリーンショット 2022-07-10 19 02 18" src="https://user-images.githubusercontent.com/55653825/178140192-b1fa307b-4492-484c-9fb2-5b44b13a7f21.png">
</p>

処理時間ウィンドウのセマンティクスを提供する、より堅牢な別の方法は、データイングレス時に到着時間をイベント時間として単純に割り当て、イベント時間ウィンドウを使用することである。到着時間のイベントタイムを使用することの副次的効果として、システムは飛行中のイベントタイムを完全に知ることができるため、遅延データなしで完全な（すなわち、非ハーリスティックな）透かしを提供することができる。これは、真のイベントタイムが必要ない、あるいは利用できないユースケースで、非束縛データを処理する効果的でコスト効率の良い方法です。他のウィンドウ表示のオプションを詳しく見る前に、このパイプラインのトリガーに対するもう1つの変更について考えてみましょう。他の一般的なウィンドウモードは、タプルベースのウィンドウをモデル化したい。この種の機能は、ある数のデータ(例えば2個)が到着した後に起動するようにトリガーを変更するだけで、提供することができます。図9では、5つの出力が得られ、それぞれが隣接する（処理時間による）2つのデータの和を含んでいる。より洗練されたタプルベースウィンドウ方式（例：スライディングタプルベースウィンドウ）にはカスタムウィンドウ戦略が必要であるが、それ以外はサポートされている。

<p align="center">
<img width="332" alt="スクリーンショット 2022-07-10 19 02 57" src="https://user-images.githubusercontent.com/55653825/178140212-a2969881-e106-4fee-a5ec-202787cf06d5.png">
</p>

ここで、非バインドソースに対応するためのもう一つの選択肢である、グローバルウィンドリングからの脱却に話を戻そう。 まず、データを2分毎の固定ウィンドウで表示する。 積算ウィンドウ。

<p align="center">
<img width="332" alt="スクリーンショット 2022-07-10 19 03 57" src="https://user-images.githubusercontent.com/55653825/178140299-273f8285-2ba0-4a84-8477-7378c618bee5.png">
</p>

トリガーストラテジーを指定しない場合、システムはデフォルトのトリガーを効果的に使用することになる。

<p align="center">
<img width="333" alt="スクリーンショット 2022-07-10 19 04 09" src="https://user-images.githubusercontent.com/55653825/178140314-e48285f6-c191-456f-82e7-270c7c46b9a4.png">
</p>

ウォーターマークトリガーは、ウォーターマークが当該ウィンドウの終端を通過したときに発生する。バッチエンジンとストリーミングエンジンの両方が、3.1節で詳述するように、透かしを実装しています。図10-12は、それぞれ異なるタイプのランタイムエンジンでのこのパイプラインの特徴を示しています。現在の実装では、データソースは限定されたものでなければならないので、上記の古典的なバッチの例と同様に、バッチ内のすべてのデータが到着するのを待つことになります。そして、図10のように、イベントタイム順にデータを処理し、シミュレーションされた透かしが進むにつれてウィンドウが表示されるようにする。

<p align="center">
<img width="256" alt="スクリーンショット 2022-07-10 19 05 29" src="https://user-images.githubusercontent.com/55653825/178140381-aad78d02-e71c-48a5-9002-47a03816b7ee.png">
</p>

このデータソースに対して、マイクロバッチエンジンが1分間のマイクロバッチを実行することを想像してください。システムは1分間の入力データを収集し、それを処理し、それを繰り返す。毎回、現在のバッチの透かしは時間の始まりから始まり、時間の終わりまで進む（その期間にはデータが存在しないので、技術的にはバッチの終了時刻から瞬時に時間の終わりまでジャンプする）。このようにして、マイクロバッチのラウンドごとに新しいウォーターマークと、前回のラウンド以降に内容が変更されたすべてのウィンドウに対応する出力が得られることになる。これにより、図11のように、遅延と最終的な正しさの非常に良い組み合わせが実現されます。

<p align="center">
<img width="262" alt="スクリーンショット 2022-07-10 19 06 46" src="https://user-images.githubusercontent.com/55653825/178140417-3bc8bbb4-90de-4ac0-ad42-24dd27b3d05d.png">
</p>

次に、このパイプラインをストリーミングエンジン上で実行した場合について考えてみる（図12）。ほとんどのウィンドウはウォーターマークが通過するときに出力される。しかし、値9を持つデータムは実際にはウォーターマークに対して遅れていることに注意。何らかの理由（モバイル入力ソースがオフライン、ネットワークパーティションなど）で、システムはデータがまだ注入されていないことに気づかず、5を観察した後、透かしをイベント時間内で最終的に9が占めるポイントを過ぎて進行させた。 したがって、9が最後に到着すると、最初のウィンドウ（イベント時間範囲 [12:00, 12:02] ）が更新された合計で再トリガーする原因となる。

<p align="center">
<img width="262" alt="スクリーンショット 2022-07-10 19 07 37" src="https://user-images.githubusercontent.com/55653825/178140435-dd4270e2-3a1b-40ae-b21c-842dd9045c6f.png">
</p>

この出力パターンは、1つのウィンドウにほぼ1つの出力があり、遅いデータの場合は1回の精密化で済むという点で良いものである。しかし、結果の全体的なレイテンシは、透かしが進むのを待たねばならないため、マイクロバッチシステムよりも明らかに悪くなる。これは、データが小バッチで処理されるのではなく、到着したウィンドウに蓄積されるため、マイクロバッチパイプラインよりも多少優れたレイテンシを得ることができます。マイクロバッチエンジンとストリーミングエンジンが強く整合している場合、それらの間の選択（マイクロバッチサイズの選択と同様に）は、まさにレイテンシとコストの問題になります。

<p align="center">
<img width="334" alt="スクリーンショット 2022-07-10 19 08 15" src="https://user-images.githubusercontent.com/55653825/178140466-fadf74d3-0136-40e3-842b-3d3c0462ac3c.png">
</p>

最後の演習として、ビデオセッションの要件を満たすために、この例を更新してみましょう（図式的な一貫性のために維持する集約操作として、合計の使用を除いて、他の集約に切り替えることは些細です）。これは、モデルを4つの部分（何を計算しているか、イベント時間のどこで計算しているか、処理時間のいつ答えを観察しているか、それらの答えが後の改良にどう関係しているか）に分割することで得られる複合性を強調し、また、さもなければ、置換として提供される値と無関係なままになっているかもしれない以前の値を戻すことの力を示している。

<p align="center">
<img width="334" alt="スクリーンショット 2022-07-10 19 09 08" src="https://user-images.githubusercontent.com/55653825/178140499-71b9358a-7662-4eba-a45e-198f81190600.png">
</p>

この例では、最初の1分間の処理時間の境界で、値5と値7の最初のシングルトンセッションを出力する。2分目の境界では、値3、4、3から構築された値10の第3のセッションを出力する。最終的に値8が観測されると、値7と10の2つのセッションが結合される。透かしがこの新しい結合セッションの終点を通過するとき、7と10のセッションのリトラクトと、新しいセッションの値25の通常のデータが出力される。同様に、9が到着すると（遅れて）、値5のセッションと値25のセッションが結合される。ウォーターマークトリガーが繰り返されると、5と25のセッションは直ちにリトラクトされ、その後39のセッションに統合される。同様のダンスが値3、8、1にも起こり、最終的に最初の3のセッションの撤回と、それに続く12のセッションの結合で終わる。
